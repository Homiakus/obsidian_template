/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  MaskBuilderPlugin: () => MaskBuilderPlugin,
  default: () => MaskBuilderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message != null ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message != null ? message : required_error) != null ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message != null ? message : invalid_type_error) != null ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (e) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (e) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false,
      local: (_b = options == null ? void 0 : options.local) != null ? _b : false,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (e) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) != null ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) != null ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) != null ? _a2 : fatal) != null ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) != null ? _a : fatal) != null ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;

// src/settings.ts
var SettingsSchema = external_exports.object({
  enabled: external_exports.boolean().default(true),
  autoCreateFolders: external_exports.boolean().default(true),
  defaultTemplate: external_exports.string().default(""),
  maskValidation: external_exports.boolean().default(true),
  maxAreas: external_exports.number().default(5),
  maxFileNameLength: external_exports.number().default(140),
  autoCategorize: external_exports.boolean().default(true),
  kbAutoMove: external_exports.boolean().default(true),
  showMaskBuilder: external_exports.boolean().default(true),
  showQuickActions: external_exports.boolean().default(true),
  debounceDelay: external_exports.number().default(300),
  cacheSize: external_exports.number().default(100),
  confirmFileOperations: external_exports.boolean().default(true),
  backupBeforeMove: external_exports.boolean().default(false),
  //   
  ribbonMenu: external_exports.object({
    enabled: external_exports.boolean().default(true),
    position: external_exports.enum(["top", "bottom"]).default("bottom"),
    actions: external_exports.array(external_exports.object({
      id: external_exports.string(),
      name: external_exports.string(),
      icon: external_exports.string(),
      action: external_exports.enum(["format", "api", "create", "custom"]),
      enabled: external_exports.boolean().default(true),
      order: external_exports.number().default(1),
      customAction: external_exports.string().optional()
    })).default([
      {
        id: "format-note",
        name: "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
        icon: "edit",
        action: "format",
        enabled: true,
        order: 1
      },
      {
        id: "send-api",
        name: "\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0432 API",
        icon: "upload",
        action: "api",
        enabled: true,
        order: 2
      },
      {
        id: "create-note",
        name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
        icon: "plus",
        action: "create",
        enabled: true,
        order: 3
      },
      {
        id: "save-template",
        name: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D",
        icon: "save",
        action: "custom",
        enabled: true,
        order: 4,
        customAction: "saveTemplate"
      },
      {
        id: "export-markdown",
        name: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 Markdown",
        icon: "download",
        action: "custom",
        enabled: true,
        order: 5,
        customAction: "exportMarkdown"
      },
      {
        id: "edit-frontmatter",
        name: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440",
        icon: "edit-3",
        action: "custom",
        enabled: true,
        order: 6,
        customAction: "editFrontmatter"
      },
      {
        id: "create-frontmatter",
        name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440",
        icon: "file-plus",
        action: "custom",
        enabled: true,
        order: 7,
        customAction: "createFrontmatter"
      },
      {
        id: "open-notes",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
        icon: "book-open",
        action: "custom",
        enabled: true,
        order: 8,
        customAction: "openNotes"
      },
      {
        id: "open-projects",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0440\u043E\u0435\u043A\u0442\u044B",
        icon: "folder",
        action: "custom",
        enabled: true,
        order: 9,
        customAction: "openProjects"
      },
      {
        id: "open-decisions",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0440\u0435\u0448\u0435\u043D\u0438\u044F",
        icon: "check-square",
        action: "custom",
        enabled: true,
        order: 10,
        customAction: "openDecisions"
      }
    ])
  })
});
var DEFAULT_SETTINGS = {
  enabled: true,
  autoCreateFolders: true,
  defaultTemplate: "",
  maskValidation: true,
  maxAreas: 5,
  maxFileNameLength: 140,
  autoCategorize: true,
  kbAutoMove: true,
  showMaskBuilder: true,
  showQuickActions: true,
  debounceDelay: 300,
  cacheSize: 100,
  confirmFileOperations: true,
  backupBeforeMove: false,
  ribbonMenu: {
    enabled: true,
    position: "bottom",
    actions: [
      {
        id: "format-note",
        name: "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
        icon: "edit",
        action: "format",
        enabled: true,
        order: 1
      },
      {
        id: "send-api",
        name: "\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0432 API",
        icon: "upload",
        action: "api",
        enabled: true,
        order: 2
      },
      {
        id: "create-note",
        name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
        icon: "plus",
        action: "create",
        enabled: true,
        order: 3
      },
      {
        id: "save-template",
        name: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D",
        icon: "save",
        action: "custom",
        enabled: true,
        order: 4,
        customAction: "saveTemplate"
      },
      {
        id: "export-markdown",
        name: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 Markdown",
        icon: "download",
        action: "custom",
        enabled: true,
        order: 5,
        customAction: "exportMarkdown"
      },
      {
        id: "edit-frontmatter",
        name: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440",
        icon: "edit-3",
        action: "custom",
        enabled: true,
        order: 6,
        customAction: "editFrontmatter"
      },
      {
        id: "create-frontmatter",
        name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440",
        icon: "file-plus",
        action: "custom",
        enabled: true,
        order: 7,
        customAction: "createFrontmatter"
      },
      {
        id: "open-notes",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
        icon: "book-open",
        action: "custom",
        enabled: true,
        order: 8,
        customAction: "openNotes"
      },
      {
        id: "open-projects",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0440\u043E\u0435\u043A\u0442\u044B",
        icon: "folder",
        action: "custom",
        enabled: true,
        order: 9,
        customAction: "openProjects"
      },
      {
        id: "open-decisions",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0440\u0435\u0448\u0435\u043D\u0438\u044F",
        icon: "check-square",
        action: "custom",
        enabled: true,
        order: 10,
        customAction: "openDecisions"
      }
    ]
  }
};
function migrateSettings(settings) {
  if (!settings.ribbonMenu) {
    settings.ribbonMenu = DEFAULT_SETTINGS.ribbonMenu;
  }
  if (settings.ribbonMenu.actions) {
    settings.ribbonMenu.actions.forEach((action) => {
      if (!action.id)
        action.id = `action-${Date.now()}`;
      if (!action.order)
        action.order = 1;
      if (!action.enabled)
        action.enabled = true;
    });
  }
  return SettingsSchema.parse(settings);
}

// src/ui/settings-tab.ts
var import_obsidian = require("obsidian");
var MaskBuilderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Mask Builder Settings" });
    this.createBasicSettings(containerEl);
    this.createMaskSettings(containerEl);
    this.createCategorizationSettings(containerEl);
    this.createUISettings(containerEl);
    this.createPerformanceSettings(containerEl);
    this.createSecuritySettings(containerEl);
  }
  createBasicSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438" });
    new import_obsidian.Setting(containerEl).setName("\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u043B\u0430\u0433\u0438\u043D").setDesc("\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0438\u043B\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0441\u0442\u044C Mask Builder").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
        this.plugin.settings.enabled = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice("\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B");
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043F\u0430\u043F\u043E\u043A").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u043F\u0440\u043E\u0435\u043A\u0442\u043E\u0432 \u0438 \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0439 \u043F\u0440\u0438 \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E\u0441\u0442\u0438").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoCreateFolders).onChange(async (value) => {
        this.plugin.settings.autoCreateFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0428\u0430\u0431\u043B\u043E\u043D \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E").setDesc("\u041F\u0443\u0442\u044C \u043A \u0444\u0430\u0439\u043B\u0443 \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u043D\u043E\u0432\u044B\u0445 \u0437\u0430\u043C\u0435\u0442\u043E\u043A (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/default.md)").addText(
      (text) => text.setPlaceholder("templates/default.md").setValue(this.plugin.settings.defaultTemplate).onChange(async (value) => {
        this.plugin.settings.defaultTemplate = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createMaskSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043C\u0430\u0441\u043E\u043A" });
    new import_obsidian.Setting(containerEl).setName("\u0412\u0430\u043B\u0438\u0434\u0430\u0446\u0438\u044F \u043C\u0430\u0441\u043E\u043A").setDesc("\u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0442\u044C \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0441\u0442\u044C \u043C\u0430\u0441\u043E\u043A \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u0444\u0430\u0439\u043B\u043E\u0432").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.maskValidation).onChange(async (value) => {
        this.plugin.settings.maskValidation = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u041C\u0430\u043A\u0441\u0438\u043C\u0443\u043C \u043E\u0431\u043B\u0430\u0441\u0442\u0435\u0439").setDesc("\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0431\u043B\u0430\u0441\u0442\u0435\u0439 \u0432 \u043C\u0430\u0441\u043A\u0435 (1-10)").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.maxAreas).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxAreas = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u0430\u044F \u0434\u043B\u0438\u043D\u0430 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430").setDesc("\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u0430\u044F \u0434\u043B\u0438\u043D\u0430 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0432 \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u0445 (50-200)").addSlider(
      (slider) => slider.setLimits(50, 200, 10).setValue(this.plugin.settings.maxFileNameLength).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxFileNameLength = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createCategorizationSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u0438" });
    new import_obsidian.Setting(containerEl).setName("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0430\u044F \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u044F").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0430\u0442\u044C \u0444\u0430\u0439\u043B\u044B \u0432 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u043F\u0430\u043F\u043A\u0438 \u043D\u0430 \u043E\u0441\u043D\u043E\u0432\u0435 \u043C\u0430\u0441\u043E\u043A").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoCategorize).onChange(async (value) => {
        this.plugin.settings.autoCategorize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435 KB \u0437\u0430\u043C\u0435\u0442\u043E\u043A").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u043E\u0431\u043B\u0430\u0441\u0442\u044C\u044E KB \u0432 \u043F\u0430\u043F\u043A\u0443 \u0431\u0430\u0437\u044B \u0437\u043D\u0430\u043D\u0438\u0439").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.kbAutoMove).onChange(async (value) => {
        this.plugin.settings.kbAutoMove = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createUISettings(containerEl) {
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430" });
    new import_obsidian.Setting(containerEl).setName("\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C Mask Builder").setDesc("\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043D\u043E\u043F\u043A\u0443 Mask Builder \u0432 \u043F\u0430\u043D\u0435\u043B\u0438 \u043A\u043E\u043C\u0430\u043D\u0434").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showMaskBuilder).onChange(async (value) => {
        this.plugin.settings.showMaskBuilder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0431\u044B\u0441\u0442\u0440\u044B\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F").setDesc("\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u0435 \u043C\u0435\u043D\u044E \u0441 \u0431\u044B\u0441\u0442\u0440\u044B\u043C\u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F\u043C\u0438 \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u043E\u0432").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showQuickActions).onChange(async (value) => {
        this.plugin.settings.showQuickActions = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createPerformanceSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438" });
    new import_obsidian.Setting(containerEl).setName("\u0417\u0430\u0434\u0435\u0440\u0436\u043A\u0430 debounce (\u043C\u0441)").setDesc("\u0417\u0430\u0434\u0435\u0440\u0436\u043A\u0430 \u0434\u043B\u044F \u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u043A\u0438 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0439 (100-2000 \u043C\u0441)").addSlider(
      (slider) => slider.setLimits(100, 2e3, 100).setValue(this.plugin.settings.debounceDelay).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.debounceDelay = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0420\u0430\u0437\u043C\u0435\u0440 \u043A\u044D\u0448\u0430").setDesc("\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432 \u0432 \u043A\u044D\u0448\u0435 (10-1000)").addSlider(
      (slider) => slider.setLimits(10, 1e3, 10).setValue(this.plugin.settings.cacheSize).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.cacheSize = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createSecuritySettings(containerEl) {
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438" });
    new import_obsidian.Setting(containerEl).setName("\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u0439 \u0441 \u0444\u0430\u0439\u043B\u0430\u043C\u0438").setDesc("\u0417\u0430\u043F\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 \u043F\u0435\u0440\u0435\u0434 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435\u043C \u0438\u043B\u0438 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u0435\u043C \u0444\u0430\u0439\u043B\u043E\u0432").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.confirmFileOperations).onChange(async (value) => {
        this.plugin.settings.confirmFileOperations = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0420\u0435\u0437\u0435\u0440\u0432\u043D\u043E\u0435 \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u043F\u0435\u0440\u0435\u0434 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435\u043C").setDesc("\u0421\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C \u0440\u0435\u0437\u0435\u0440\u0432\u043D\u0443\u044E \u043A\u043E\u043F\u0438\u044E \u0444\u0430\u0439\u043B\u0430 \u043F\u0435\u0440\u0435\u0434 \u0435\u0433\u043E \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u0435\u043C").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.backupBeforeMove).onChange(async (value) => {
        this.plugin.settings.backupBeforeMove = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/ui/mask-builder-modal.ts
var import_obsidian2 = require("obsidian");

// src/utils/entity-finder.ts
var EntityFinder = class {
  constructor(app) {
    this.cache = /* @__PURE__ */ new Map();
    this.cacheTimeout = 5 * 60 * 1e3;
    // 5 
    this.lastCacheUpdate = 0;
    this.app = app;
  }
  /**
   *    
   */
  async getEntitySuggestions() {
    await this.updateCacheIfNeeded();
    return this.cache.get("entities") || [];
  }
  /**
   *    
   */
  async getAreaSuggestions() {
    await this.updateCacheIfNeeded();
    return this.cache.get("areas") || [];
  }
  /**
   *    
   */
  async getStatusSuggestions() {
    await this.updateCacheIfNeeded();
    return this.cache.get("statuses") || [];
  }
  /**
   *     
   */
  async getAccessSuggestions() {
    await this.updateCacheIfNeeded();
    return this.cache.get("accesses") || [];
  }
  /**
   *    
   */
  async getFormatSuggestions() {
    await this.updateCacheIfNeeded();
    return this.cache.get("formats") || [];
  }
  /**
   *    
   */
  async getAnchorSuggestions() {
    await this.updateCacheIfNeeded();
    return this.cache.get("anchors") || [];
  }
  /**
   *    
   */
  async searchEntities(query) {
    const entities = await this.getEntitySuggestions();
    if (!query)
      return entities;
    const lowerQuery = query.toLowerCase();
    return entities.filter(
      (entity) => entity.value.toLowerCase().includes(lowerQuery) || entity.label.toLowerCase().includes(lowerQuery)
    );
  }
  /**
   *    
   */
  async searchAreas(query) {
    const areas = await this.getAreaSuggestions();
    if (!query)
      return areas;
    const lowerQuery = query.toLowerCase();
    return areas.filter(
      (area) => area.value.toLowerCase().includes(lowerQuery) || area.label.toLowerCase().includes(lowerQuery)
    );
  }
  /**
   *    
   */
  async searchAnchors(query) {
    const anchors = await this.getAnchorSuggestions();
    if (!query)
      return anchors;
    const lowerQuery = query.toLowerCase();
    return anchors.filter(
      (anchor) => anchor.value.toLowerCase().includes(lowerQuery) || anchor.label.toLowerCase().includes(lowerQuery)
    );
  }
  /**
   *    
   */
  async updateCacheIfNeeded() {
    const now = Date.now();
    if (now - this.lastCacheUpdate < this.cacheTimeout) {
      return;
    }
    await this.updateCache();
    this.lastCacheUpdate = now;
  }
  /**
   *      
   */
  async updateCache() {
    const entities = /* @__PURE__ */ new Map();
    const areas = /* @__PURE__ */ new Map();
    const statuses = /* @__PURE__ */ new Map();
    const accesses = /* @__PURE__ */ new Map();
    const formats = /* @__PURE__ */ new Map();
    const anchors = /* @__PURE__ */ new Map();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        const frontmatter = this.extractFrontmatter(content);
        if (frontmatter) {
          if (frontmatter.entity) {
            const count = entities.get(frontmatter.entity) || 0;
            entities.set(frontmatter.entity, count + 1);
          }
          if (frontmatter.areas && Array.isArray(frontmatter.areas)) {
            for (const area of frontmatter.areas) {
              const count = areas.get(area) || 0;
              areas.set(area, count + 1);
            }
          }
          if (frontmatter.status) {
            const count = statuses.get(frontmatter.status) || 0;
            statuses.set(frontmatter.status, count + 1);
          }
          if (frontmatter.access) {
            const count = accesses.get(frontmatter.access) || 0;
            accesses.set(frontmatter.access, count + 1);
          }
          if (frontmatter.format) {
            const count = formats.get(frontmatter.format) || 0;
            formats.set(frontmatter.format, count + 1);
          }
          if (frontmatter.anchor) {
            const count = anchors.get(frontmatter.anchor) || 0;
            anchors.set(frontmatter.anchor, count + 1);
          }
        }
      } catch (error) {
        console.warn(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0447\u0442\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${file.path}:`, error);
      }
    }
    this.addStandardValues(entities, areas, statuses, accesses, formats, anchors);
    this.cache.set("entities", this.mapToSuggestions(entities, "entity"));
    this.cache.set("areas", this.mapToSuggestions(areas, "area"));
    this.cache.set("statuses", this.mapToSuggestions(statuses, "status"));
    this.cache.set("accesses", this.mapToSuggestions(accesses, "access"));
    this.cache.set("formats", this.mapToSuggestions(formats, "format"));
    this.cache.set("anchors", this.mapToSuggestions(anchors, "anchor"));
  }
  /**
   *   
   */
  addStandardValues(entities, areas, statuses, accesses, formats, anchors) {
    const standardEntities = ["NOTE", "DEC", "ADR", "PROJ", "TASK", "MEETING", "IDEA"];
    standardEntities.forEach((entity) => {
      if (!entities.has(entity)) {
        entities.set(entity, 0);
      }
    });
    const standardAreas = ["ENG", "DEV", "MED", "KB", "PROJ", "TASK", "MEETING"];
    standardAreas.forEach((area) => {
      if (!areas.has(area)) {
        areas.set(area, 0);
      }
    });
    const standardStatuses = ["DRA", "AC", "PAU", "DON", "DEP"];
    standardStatuses.forEach((status) => {
      if (!statuses.has(status)) {
        statuses.set(status, 0);
      }
    });
    const standardAccesses = ["PUB", "INT", "PRV"];
    standardAccesses.forEach((access) => {
      if (!accesses.has(access)) {
        accesses.set(access, 0);
      }
    });
    const standardFormats = ["MD", "TXT", "DOC"];
    standardFormats.forEach((format) => {
      if (!formats.has(format)) {
        formats.set(format, 0);
      }
    });
    const standardAnchors = ["CAT-KB", "CAT-DEV", "CAT-MED", "PROJ-MAIN", "PROJ-SIDE"];
    standardAnchors.forEach((anchor) => {
      if (!anchors.has(anchor)) {
        anchors.set(anchor, 0);
      }
    });
  }
  /**
   *     
   */
  extractFrontmatter(content) {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch)
      return null;
    try {
      const frontmatterText = frontmatterMatch[1];
      if (!frontmatterText)
        return null;
      const lines = frontmatterText.split("\n");
      const result = {};
      for (const line of lines) {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          let value = line.substring(colonIndex + 1).trim();
          if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
            value = value.substring(1, value.length - 1);
          }
          if (value.startsWith("[") && value.endsWith("]")) {
            try {
              value = JSON.parse(value);
            } catch (e) {
            }
          }
          result[key] = value;
        }
      }
      return result;
    } catch (error) {
      console.warn("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0430\u0440\u0441\u0438\u043D\u0433\u0430 \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440\u0430:", error);
      return null;
    }
  }
  /**
   *  Map   
   */
  mapToSuggestions(map, type) {
    return Array.from(map.entries()).map(([value, count]) => ({
      value,
      label: this.getLabel(value, type),
      count,
      type
    })).sort((a, b) => b.count - a.count || a.value.localeCompare(b.value));
  }
  /**
   *     
   */
  getLabel(value, type) {
    var _a;
    const labels = {
      entity: {
        "NOTE": "\u0417\u0430\u043C\u0435\u0442\u043A\u0430",
        "DEC": "\u0420\u0435\u0448\u0435\u043D\u0438\u0435",
        "ADR": "\u0410\u0440\u0445\u0438\u0442\u0435\u043A\u0442\u0443\u0440\u043D\u043E\u0435 \u0440\u0435\u0448\u0435\u043D\u0438\u0435",
        "PROJ": "\u041F\u0440\u043E\u0435\u043A\u0442",
        "TASK": "\u0417\u0430\u0434\u0430\u0447\u0430",
        "MEETING": "\u0412\u0441\u0442\u0440\u0435\u0447\u0430",
        "IDEA": "\u0418\u0434\u0435\u044F"
      },
      area: {
        "ENG": "\u0418\u043D\u0436\u0435\u043D\u0435\u0440\u0438\u044F",
        "DEV": "\u0420\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0430",
        "MED": "\u041C\u0435\u0434\u0438\u0446\u0438\u043D\u0430",
        "KB": "\u0411\u0430\u0437\u0430 \u0437\u043D\u0430\u043D\u0438\u0439",
        "PROJ": "\u041F\u0440\u043E\u0435\u043A\u0442\u044B",
        "TASK": "\u0417\u0430\u0434\u0430\u0447\u0438",
        "MEETING": "\u0412\u0441\u0442\u0440\u0435\u0447\u0438"
      },
      status: {
        "DRA": "\u0427\u0435\u0440\u043D\u043E\u0432\u0438\u043A",
        "AC": "\u0410\u043A\u0442\u0438\u0432\u043D\u044B\u0439",
        "PAU": "\u041F\u0440\u0438\u043E\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D",
        "DON": "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D",
        "DEP": "\u0423\u0441\u0442\u0430\u0440\u0435\u043B"
      },
      access: {
        "PUB": "\u041F\u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0439",
        "INT": "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u0438\u0439",
        "PRV": "\u041F\u0440\u0438\u0432\u0430\u0442\u043D\u044B\u0439"
      },
      format: {
        "MD": "Markdown",
        "TXT": "\u0422\u0435\u043A\u0441\u0442",
        "DOC": "\u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442"
      },
      anchor: {
        "CAT-KB": "\u041A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u044F: \u0411\u0430\u0437\u0430 \u0437\u043D\u0430\u043D\u0438\u0439",
        "CAT-DEV": "\u041A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u044F: \u0420\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u043A\u0430",
        "CAT-MED": "\u041A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u044F: \u041C\u0435\u0434\u0438\u0446\u0438\u043D\u0430",
        "PROJ-MAIN": "\u041F\u0440\u043E\u0435\u043A\u0442: \u041E\u0441\u043D\u043E\u0432\u043D\u043E\u0439",
        "PROJ-SIDE": "\u041F\u0440\u043E\u0435\u043A\u0442: \u041F\u043E\u0431\u043E\u0447\u043D\u044B\u0439"
      }
    };
    return ((_a = labels[type]) == null ? void 0 : _a[value]) || value;
  }
  /**
   *  
   */
  clearCache() {
    this.cache.clear();
    this.lastCacheUpdate = 0;
  }
};

// src/utils/mask-parser.ts
var AreaSchema = external_exports.enum([
  "LLM",
  "MED",
  "ENG",
  "HYP",
  "HLTH",
  "ACC",
  "KB",
  "LNX",
  "WIN",
  "TRIZ",
  "SYSAN",
  "DEV",
  "ELEC",
  "CNMKT"
]);
var StatusSchema = external_exports.enum(["DRA", "AC", "PAU", "DON", "DEP"]);
var AccessSchema = external_exports.enum(["PUB", "INT", "PRV"]);
var FormatSchema = external_exports.enum(["MD", "GLB", "CAD", "PDF", "PNG", "SRC"]);
var MaskSchema = external_exports.object({
  entity: external_exports.string().min(1).max(50),
  areas: external_exports.array(AreaSchema).min(1).max(5),
  status: StatusSchema.optional(),
  access: AccessSchema.optional(),
  format: FormatSchema.optional(),
  references: external_exports.array(external_exports.string()).optional(),
  anchor: external_exports.string().min(1).max(100)
});
var MASK_REGEX = /^([A-Z]+(?:-[A-Z]+)*)(?:\.([A-Z]{2,4}))?(?:\.([A-Z]{2,4}))?(?:\.([A-Z]{2,4}))?(?:\.([A-Z]{2,4}))?(?:\.([A-Z]{2,4}))?(?:\.([A-Z]{2,4}))?(?:\+([A-Z-]+(?:,[A-Z-]+)*))?@([A-Z-]+)$/;
var MaskParser = class {
  /**
   *      
   */
  static parse(maskString) {
    var _a;
    const match = maskString.match(MASK_REGEX);
    if (!match)
      return null;
    const [, entity, ...parts] = match;
    const areas = [];
    let status;
    let access;
    let format;
    let references;
    let anchor;
    for (let i = 0; i < parts.length - 2; i++) {
      const part = parts[i];
      if (!part)
        continue;
      if (AreaSchema.safeParse(part).success) {
        areas.push(part);
      } else if (StatusSchema.safeParse(part).success) {
        status = part;
      } else if (AccessSchema.safeParse(part).success) {
        access = part;
      } else if (FormatSchema.safeParse(part).success) {
        format = part;
      }
    }
    if (parts.length >= 2) {
      const refPart = parts[parts.length - 2];
      if (refPart) {
        references = refPart.split(",");
      }
    }
    anchor = (_a = parts[parts.length - 1]) != null ? _a : "";
    return {
      entity: entity != null ? entity : "",
      areas,
      status: status != null ? status : "",
      access: access != null ? access : "",
      format: format != null ? format : "",
      references: references != null ? references : [],
      anchor: anchor != null ? anchor : ""
    };
  }
  /**
   *     CTM
   */
  static validate(mask) {
    const errors = [];
    if (mask.areas.length > 5) {
      errors.push("\u041C\u0430\u0441\u043A\u0430 \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043D\u0435 \u0431\u043E\u043B\u0435\u0435 5 \u043E\u0431\u043B\u0430\u0441\u0442\u0435\u0439");
    }
    const uniqueAreas = new Set(mask.areas);
    if (uniqueAreas.size !== mask.areas.length) {
      errors.push("\u041E\u0431\u043B\u0430\u0441\u0442\u0438 \u0432 \u043C\u0430\u0441\u043A\u0435 \u0434\u043E\u043B\u0436\u043D\u044B \u0431\u044B\u0442\u044C \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u043C\u0438");
    }
    if (!mask.anchor) {
      errors.push("\u041C\u0430\u0441\u043A\u0430 \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u044F\u043A\u043E\u0440\u044C (\u043F\u0440\u043E\u0435\u043A\u0442 \u0438\u043B\u0438 \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u044E)");
    }
    const fileName = this.generateFileName(mask);
    if (fileName.length > 140) {
      errors.push("\u0414\u043B\u0438\u043D\u0430 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u0430 \u043F\u0440\u0435\u0432\u044B\u0448\u0430\u0442\u044C 140 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432");
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  /**
   *      
   */
  static generateFileName(mask) {
    const parts = [mask.entity];
    if (mask.areas.length > 0) {
      parts.push(...mask.areas);
    }
    if (mask.status) {
      parts.push(mask.status);
    }
    if (mask.access) {
      parts.push(mask.access);
    }
    if (mask.format) {
      parts.push(mask.format);
    }
    if (mask.references && mask.references.length > 0) {
      parts.push(`+${mask.references.join(",")}`);
    }
    parts.push(`@${mask.anchor}`);
    return parts.join(".");
  }
  /**
   *    (  )
   */
  static getAnchorType(anchor) {
    if (anchor.startsWith("PROJ-")) {
      return "project";
    } else if (anchor.startsWith("CAT-")) {
      return "category";
    }
    return "unknown";
  }
  /**
   *       
   */
  static generateFilePath(mask, vaultPath) {
    const anchorType = this.getAnchorType(mask.anchor);
    if (anchorType === "project") {
      return `${vaultPath}/1_PROJECTS/${mask.anchor}/notes/`;
    } else if (anchorType === "category") {
      const isKB = mask.areas.includes("KB") || mask.anchor === "CAT-KB";
      if (isKB) {
        return `${vaultPath}/2_CATEGORIES/${mask.anchor}/notes/`;
      }
      return `${vaultPath}/2_CATEGORIES/${mask.anchor}/notes/`;
    }
    return `${vaultPath}/0_INBOX/`;
  }
};

// src/ui/mask-builder-modal.ts
var MaskBuilderModal = class extends import_obsidian2.Modal {
  constructor(app, fileManager, onSubmit) {
    super(app);
    this.fileManager = fileManager;
    this.entityFinder = new EntityFinder(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("mask-builder-modal");
    this.createForm();
    this.setupAutocomplete(this.areasInput, "area");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.removeClass("mask-builder-modal");
  }
  createForm() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043F\u043E \u043C\u0430\u0441\u043A\u0435" });
    const form = contentEl.createEl("form");
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      this.handleSubmit();
    });
    const areasGroup = form.createEl("div", { cls: "form-group" });
    areasGroup.createEl("label", {
      text: "\u041E\u0431\u043B\u0430\u0441\u0442\u0438 \u0437\u043D\u0430\u043D\u0438\u0439 \u0447\u0435\u0440\u0435\u0437 \u0442\u043E\u0447\u043A\u0443 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: ENG.DEV.MED)",
      attr: { for: "areas" }
    });
    this.areasInput = areasGroup.createEl("input", {
      type: "text",
      value: "ENG.DEV.MED"
    });
    const statusGroup = form.createEl("div", { cls: "form-group" });
    statusGroup.createEl("label", {
      text: "\u0421\u0442\u0430\u0442\u0443\u0441",
      attr: { for: "status" }
    });
    statusGroup.createEl("small", { text: "\u0421\u0442\u0430\u0442\u0443\u0441 \u0437\u0430\u043C\u0435\u0442\u043A\u0438" });
    this.statusInput = statusGroup.createEl("select");
    this.statusInput.createEl("option", { text: "\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D", value: "" });
    this.statusInput.createEl("option", { text: "\u0427\u0435\u0440\u043D\u043E\u0432\u0438\u043A", value: "DRA" });
    this.statusInput.createEl("option", { text: "\u0412 \u0440\u0430\u0431\u043E\u0442\u0435", value: "AC" });
    this.statusInput.createEl("option", { text: "\u041F\u0440\u0438\u043E\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u043E", value: "PAU" });
    this.statusInput.createEl("option", { text: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E", value: "DON" });
    this.statusInput.createEl("option", { text: "\u041E\u0442\u043B\u043E\u0436\u0435\u043D\u043E", value: "DEP" });
    const accessGroup = form.createEl("div", { cls: "form-group" });
    accessGroup.createEl("label", {
      text: "\u0414\u043E\u0441\u0442\u0443\u043F",
      attr: { for: "access" }
    });
    accessGroup.createEl("small", { text: "\u0423\u0440\u043E\u0432\u0435\u043D\u044C \u0434\u043E\u0441\u0442\u0443\u043F\u0430" });
    this.accessInput = accessGroup.createEl("select");
    this.accessInput.createEl("option", { text: "\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D", value: "" });
    this.accessInput.createEl("option", { text: "\u041F\u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0439", value: "PUB" });
    this.accessInput.createEl("option", { text: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u0438\u0439", value: "INT" });
    this.accessInput.createEl("option", { text: "\u041F\u0440\u0438\u0432\u0430\u0442\u043D\u044B\u0439", value: "PRV" });
    const formatGroup = form.createEl("div", { cls: "form-group" });
    formatGroup.createEl("label", {
      text: "\u0424\u043E\u0440\u043C\u0430\u0442",
      attr: { for: "format" }
    });
    formatGroup.createEl("small", { text: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430" });
    this.formatInput = formatGroup.createEl("select");
    this.formatInput.createEl("option", { text: "\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D", value: "" });
    this.formatInput.createEl("option", { text: "Markdown", value: "MD" });
    this.formatInput.createEl("option", { text: "\u0413\u043B\u043E\u0431\u0443\u0441", value: "GLB" });
    this.formatInput.createEl("option", { text: "Markdown", value: "MD" });
    this.formatInput.createEl("option", { text: "\u0413\u043B\u043E\u0431\u0443\u0441", value: "GLB" });
    this.formatInput.createEl("option", { text: "CAD", value: "CAD" });
    this.formatInput.createEl("option", { text: "PDF", value: "PDF" });
    this.formatInput.createEl("option", { text: "PNG", value: "PNG" });
    this.formatInput.createEl("option", { text: "\u0418\u0441\u0445\u043E\u0434\u043D\u044B\u0439 \u043A\u043E\u0434", value: "SRC" });
    const referencesGroup = form.createEl("div", { cls: "form-group" });
    referencesGroup.createEl("label", {
      text: "\u0421\u0441\u044B\u043B\u043A\u0438",
      attr: { for: "references" }
    });
    referencesGroup.createEl("small", { text: "\u0421\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0435 \u0441\u0441\u044B\u043B\u043A\u0438 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E" });
    this.referencesInput = referencesGroup.createEl("input", {
      type: "text",
      value: "ref1, ref2, ref3"
    });
    const anchorGroup = form.createEl("div", { cls: "form-group" });
    anchorGroup.createEl("label", {
      text: "\u042F\u043A\u043E\u0440\u044C",
      attr: { for: "anchor" }
    });
    anchorGroup.createEl("small", { text: "\u042F\u043A\u043E\u0440\u044C \u0434\u043B\u044F \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u0438 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: CAT-KB, PROJ-MAIN)" });
    this.anchorInput = anchorGroup.createEl("input", {
      type: "text",
      value: "CAT-KB"
    });
    const contentGroup = form.createEl("div", { cls: "form-group" });
    contentGroup.createEl("label", {
      text: "\u0421\u043E\u0434\u0435\u0440\u0436\u0430\u043D\u0438\u0435",
      attr: { for: "content" }
    });
    contentGroup.createEl("small", { text: "\u0421\u043E\u0434\u0435\u0440\u0436\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438" });
    this.contentInput = contentGroup.createEl("textarea", {
      placeholder: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438..."
    });
    const previewGroup = form.createEl("div", { cls: "form-group" });
    previewGroup.createEl("h3", { text: "\u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440" });
    previewGroup.createEl("p", { text: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0434\u043B\u044F \u043F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0433\u043E \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0430" });
    const buttonGroup = form.createEl("div", { cls: "form-actions" });
    buttonGroup.createEl("button", {
      type: "submit",
      text: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
      cls: "btn btn-primary"
    });
    buttonGroup.createEl("button", {
      type: "button",
      text: "\u041E\u0442\u043C\u0435\u043D\u0430",
      cls: "btn btn-secondary",
      attr: { onclick: "this.closest('.modal').close()" }
    });
  }
  handleSubmit() {
    const mask = this.buildMaskFromForm();
    if (!mask) {
      new import_obsidian2.Notice("\u0417\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043F\u043E\u043B\u044F: \u0421\u0443\u0449\u043D\u043E\u0441\u0442\u044C \u0438 \u042F\u043A\u043E\u0440\u044C");
      return;
    }
    const validation = MaskParser.validate(mask);
    if (!validation.valid) {
      new import_obsidian2.Notice(`\u041E\u0448\u0438\u0431\u043A\u0438 \u0432 \u043C\u0430\u0441\u043A\u0435: ${validation.errors.join(", ")}`);
      return;
    }
    const content = this.contentInput.value;
    this.onSubmit(mask, content);
    this.close();
    new import_obsidian2.Notice("\u0417\u0430\u043C\u0435\u0442\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E!");
  }
  buildMaskFromForm() {
    const entity = this.entityInput.value.trim();
    const areas = this.areasInput.value.trim().split(".").filter((area) => area.trim());
    const status = this.statusInput.value || void 0;
    const access = this.accessInput.value || void 0;
    const format = this.formatInput.value || void 0;
    const references = this.referencesInput.value.trim().split(",").filter((ref) => ref.trim());
    const anchor = this.anchorInput.value.trim();
    if (!entity || !anchor) {
      return null;
    }
    return {
      entity,
      areas,
      status: status != null ? status : "",
      access: access != null ? access : "",
      format: format != null ? format : "",
      references: references.length > 0 ? references : [],
      anchor
    };
  }
  /**
   *     
   */
  setupAutocomplete(input, type) {
    let suggestions = [];
    let currentIndex = -1;
    let dropdown = null;
    const showSuggestions = async () => {
      const query = input.value;
      if (query.length < 1) {
        hideSuggestions();
        return;
      }
      try {
        switch (type) {
          case "entity":
            suggestions = await this.entityFinder.searchEntities(query);
            break;
          case "area":
            suggestions = await this.entityFinder.searchAreas(query);
            break;
          case "anchor":
            suggestions = await this.entityFinder.searchAnchors(query);
            break;
        }
        if (suggestions.length === 0) {
          hideSuggestions();
          return;
        }
        showDropdown();
      } catch (error) {
        console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u043E\u0438\u0441\u043A\u0430 \u043F\u0440\u0435\u0434\u043B\u043E\u0436\u0435\u043D\u0438\u0439:", error);
      }
    };
    const showDropdown = () => {
      hideSuggestions();
      dropdown = document.createElement("div");
      dropdown.className = "mask-builder-suggestions";
      dropdown.style.cssText = `
        position: absolute;
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        width: ${input.offsetWidth}px;
      `;
      suggestions.forEach((suggestion, index) => {
        const item = document.createElement("div");
        item.className = "suggestion-item";
        item.style.cssText = `
          padding: 8px 12px;
          cursor: pointer;
          border-bottom: 1px solid var(--background-modifier-border);
        `;
        item.innerHTML = `
          <div style="font-weight: bold;">${suggestion.value}</div>
          <div style="font-size: 0.8em; color: var(--text-muted);">
            ${suggestion.label} (${suggestion.count})
          </div>
        `;
        item.addEventListener("click", () => {
          input.value = suggestion.value;
          input.dispatchEvent(new Event("input"));
          hideSuggestions();
        });
        item.addEventListener("mouseenter", () => {
          currentIndex = index;
          updateSelection();
        });
        if (dropdown) {
          dropdown.appendChild(item);
        }
      });
      if (dropdown) {
        const rect = input.getBoundingClientRect();
        dropdown.style.top = `${rect.bottom + 5}px`;
        dropdown.style.left = `${rect.left}px`;
        document.body.appendChild(dropdown);
      }
    };
    const hideSuggestions = () => {
      if (dropdown) {
        dropdown.remove();
        dropdown = null;
      }
      currentIndex = -1;
    };
    const updateSelection = () => {
      const items = dropdown == null ? void 0 : dropdown.querySelectorAll(".suggestion-item");
      if (items && dropdown) {
        items.forEach((item, index) => {
          const itemElement = item;
          if (index === currentIndex) {
            itemElement.style.backgroundColor = "var(--background-modifier-hover)";
          } else {
            itemElement.style.backgroundColor = "";
          }
        });
      }
    };
    input.addEventListener("input", showSuggestions);
    input.addEventListener("focus", showSuggestions);
    input.addEventListener("blur", () => {
      setTimeout(hideSuggestions, 200);
    });
    input.addEventListener("keydown", (e) => {
      if (!dropdown)
        return;
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          currentIndex = Math.min(currentIndex + 1, suggestions.length - 1);
          updateSelection();
          break;
        case "ArrowUp":
          e.preventDefault();
          currentIndex = Math.max(currentIndex - 1, -1);
          updateSelection();
          break;
        case "Enter":
          e.preventDefault();
          if (currentIndex >= 0 && suggestions[currentIndex]) {
            const suggestion = suggestions[currentIndex];
            if (suggestion && suggestion.value) {
              input.value = suggestion.value;
              input.dispatchEvent(new Event("input"));
              hideSuggestions();
            }
          }
          break;
        case "Escape":
          hideSuggestions();
          break;
      }
    });
  }
  /**
   *  dropdown   EntityFinder
   */
  async populateDropdown(dropdown, type) {
    try {
      let suggestions = [];
      switch (type) {
        case "status":
          suggestions = await this.entityFinder.getStatusSuggestions();
          break;
        case "access":
          suggestions = await this.entityFinder.getAccessSuggestions();
          break;
        case "format":
          suggestions = await this.entityFinder.getFormatSuggestions();
          break;
      }
      dropdown.addOption("", "\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D");
      suggestions.forEach((suggestion) => {
        dropdown.addOption(suggestion.value, `${suggestion.value} - ${suggestion.label}`);
      });
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u043F\u0440\u0435\u0434\u043B\u043E\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F ${type}:`, error);
      const fallbackValues = {
        status: ["DRA", "AC", "PAU", "DON", "DEP"],
        access: ["PUB", "INT", "PRV"],
        format: ["MD", "TXT", "DOC"]
      };
      fallbackValues[type].forEach((value) => {
        dropdown.addOption(value, value);
      });
    }
  }
};

// src/ui/debug-panel.ts
var import_obsidian5 = require("obsidian");

// src/utils/performance-monitor.ts
var import_obsidian3 = require("obsidian");
var PerformanceMonitor = class {
  constructor() {
    this.metrics = {
      pluginLoadTime: 0,
      fileProcessingTime: 0,
      maskValidationTime: 0,
      fileOperationsTime: 0,
      memoryUsage: 0,
      cacheHitRate: 0
    };
    this.cacheHits = 0;
    this.cacheMisses = 0;
    this.timers = /* @__PURE__ */ new Map();
  }
  /**
   *     
   */
  startTimer(operation) {
    this.timers.set(operation, performance.now());
  }
  /**
   *     
   */
  endTimer(operation) {
    const startTime = this.timers.get(operation);
    if (!startTime) {
      console.warn(`Timer for operation '${operation}' was not started`);
      return 0;
    }
    const duration = performance.now() - startTime;
    this.timers.delete(operation);
    switch (operation) {
      case "pluginLoad":
        this.metrics.pluginLoadTime = duration;
        break;
      case "fileProcessing":
        this.metrics.fileProcessingTime = duration;
        break;
      case "maskValidation":
        this.metrics.maskValidationTime = duration;
        break;
      case "fileOperations":
        this.metrics.fileOperationsTime = duration;
        break;
    }
    return duration;
  }
  /**
   *    
   */
  recordCacheHit() {
    this.cacheHits++;
    this.updateCacheHitRate();
  }
  /**
   *   
   */
  recordCacheMiss() {
    this.cacheMisses++;
    this.updateCacheHitRate();
  }
  /**
   *     
   */
  updateCacheHitRate() {
    const total = this.cacheHits + this.cacheMisses;
    this.metrics.cacheHitRate = total > 0 ? this.cacheHits / total * 100 : 0;
  }
  /**
   *    
   */
  updateMemoryUsage() {
    if ("memory" in performance) {
      const memory = performance.memory;
      this.metrics.memoryUsage = memory.usedJSHeapSize / 1024 / 1024;
    }
  }
  /**
   *   
   */
  getMetrics() {
    this.updateMemoryUsage();
    return { ...this.metrics };
  }
  /**
   *    
   */
  logPerformanceReport() {
    const metrics = this.getMetrics();
    console.group("\u{1F3AF} Mask Builder Performance Report");
    console.log(`Plugin Load Time: ${metrics.pluginLoadTime.toFixed(2)}ms`);
    console.log(`File Processing Time: ${metrics.fileProcessingTime.toFixed(2)}ms`);
    console.log(`Mask Validation Time: ${metrics.maskValidationTime.toFixed(2)}ms`);
    console.log(`File Operations Time: ${metrics.fileOperationsTime.toFixed(2)}ms`);
    console.log(`Memory Usage: ${metrics.memoryUsage.toFixed(2)}MB`);
    console.log(`Cache Hit Rate: ${metrics.cacheHitRate.toFixed(1)}%`);
    console.log(`Cache Hits: ${this.cacheHits}, Misses: ${this.cacheMisses}`);
    console.groupEnd();
    this.checkPerformanceIssues(metrics);
  }
  /**
   *     
   */
  checkPerformanceIssues(metrics) {
    const issues = [];
    if (metrics.pluginLoadTime > 1e3) {
      issues.push("\u041C\u0435\u0434\u043B\u0435\u043D\u043D\u0430\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430");
    }
    if (metrics.fileProcessingTime > 500) {
      issues.push("\u041C\u0435\u0434\u043B\u0435\u043D\u043D\u0430\u044F \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0444\u0430\u0439\u043B\u043E\u0432");
    }
    if (metrics.memoryUsage > 100) {
      issues.push("\u0412\u044B\u0441\u043E\u043A\u043E\u0435 \u043F\u043E\u0442\u0440\u0435\u0431\u043B\u0435\u043D\u0438\u0435 \u043F\u0430\u043C\u044F\u0442\u0438");
    }
    if (metrics.cacheHitRate < 50) {
      issues.push("\u041D\u0438\u0437\u043A\u0430\u044F \u044D\u0444\u0444\u0435\u043A\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C \u043A\u044D\u0448\u0430");
    }
    if (issues.length > 0) {
      new import_obsidian3.Notice(`\u26A0\uFE0F \u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438: ${issues.join(", ")}`);
    }
  }
  /**
   *   
   */
  reset() {
    this.metrics = {
      pluginLoadTime: 0,
      fileProcessingTime: 0,
      maskValidationTime: 0,
      fileOperationsTime: 0,
      memoryUsage: 0,
      cacheHitRate: 0
    };
    this.cacheHits = 0;
    this.cacheMisses = 0;
    this.timers.clear();
  }
  /**
   *    JSON
   */
  exportMetrics() {
    return JSON.stringify({
      metrics: this.getMetrics(),
      cacheStats: {
        hits: this.cacheHits,
        misses: this.cacheMisses,
        hitRate: this.metrics.cacheHitRate
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }, null, 2);
  }
};
var performanceMonitor = new PerformanceMonitor();

// src/utils/error-handler.ts
var import_obsidian4 = require("obsidian");
var ErrorSeverity = /* @__PURE__ */ ((ErrorSeverity2) => {
  ErrorSeverity2["LOW"] = "low";
  ErrorSeverity2["MEDIUM"] = "medium";
  ErrorSeverity2["HIGH"] = "high";
  ErrorSeverity2["CRITICAL"] = "critical";
  return ErrorSeverity2;
})(ErrorSeverity || {});
var ErrorCategory = /* @__PURE__ */ ((ErrorCategory2) => {
  ErrorCategory2["VALIDATION"] = "validation";
  ErrorCategory2["FILE_OPERATION"] = "file_operation";
  ErrorCategory2["PARSING"] = "parsing";
  ErrorCategory2["NETWORK"] = "network";
  ErrorCategory2["PERMISSION"] = "permission";
  ErrorCategory2["UNKNOWN"] = "unknown";
  return ErrorCategory2;
})(ErrorCategory || {});
var ErrorHandler = class {
  constructor() {
    this.errors = [];
    this.maxErrors = 100;
    this.errorCounts = /* @__PURE__ */ new Map();
  }
  /**
   *       
   */
  handleError(error, category = "unknown" /* UNKNOWN */, severity = "medium" /* MEDIUM */, context, recoverable = true) {
    var _a;
    const errorInfo = {
      message: typeof error === "string" ? error : error.message,
      severity,
      category,
      timestamp: /* @__PURE__ */ new Date(),
      context: context != null ? context : {},
      stack: error instanceof Error ? (_a = error.stack) != null ? _a : "" : "",
      recoverable
    };
    this.errors.push(errorInfo);
    this.trackErrorCount(errorInfo.message);
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    this.logError(errorInfo);
    if (severity === "critical" /* CRITICAL */) {
      this.showErrorNotification(errorInfo);
    }
    if (severity === "high" /* HIGH */ && this.getErrorCount(errorInfo.message) === 1) {
      this.showErrorNotification(errorInfo);
    }
  }
  /**
   *   
   */
  handleValidationError(message, context) {
    this.handleError(
      message,
      "validation" /* VALIDATION */,
      "medium" /* MEDIUM */,
      context,
      true
    );
  }
  /**
   *    
   */
  handleFileOperationError(error, context) {
    this.handleError(
      error,
      "file_operation" /* FILE_OPERATION */,
      "high" /* HIGH */,
      context,
      true
    );
  }
  /**
   *   
   */
  handleParsingError(message, context) {
    this.handleError(
      message,
      "parsing" /* PARSING */,
      "medium" /* MEDIUM */,
      context,
      true
    );
  }
  /**
   *   
   */
  handleCriticalError(error, context) {
    this.handleError(
      error,
      "unknown" /* UNKNOWN */,
      "critical" /* CRITICAL */,
      context,
      false
    );
  }
  /**
   *     
   */
  trackErrorCount(message) {
    const count = this.errorCounts.get(message) || 0;
    this.errorCounts.set(message, count + 1);
  }
  /**
   *     
   */
  getErrorCount(message) {
    return this.errorCounts.get(message) || 0;
  }
  /**
   *    
   */
  logError(errorInfo) {
    const prefix = `[Mask Builder] [${errorInfo.category.toUpperCase()}] [${errorInfo.severity.toUpperCase()}]`;
    console.group(`${prefix} ${errorInfo.message}`);
    console.log("Timestamp:", errorInfo.timestamp.toISOString());
    if (errorInfo.context) {
      console.log("Context:", errorInfo.context);
    }
    if (errorInfo.stack) {
      console.log("Stack:", errorInfo.stack);
    }
    console.log("Recoverable:", errorInfo.recoverable);
    console.groupEnd();
  }
  /**
   *    
   */
  showErrorNotification(errorInfo) {
    const prefix = `[${errorInfo.category.toUpperCase()}]`;
    const message = `${prefix} ${errorInfo.message}`;
    new import_obsidian4.Notice(message, 5e3);
  }
  /**
   *   
   */
  getErrors() {
    return [...this.errors];
  }
  /**
   *    
   */
  getErrorsByCategory(category) {
    return this.errors.filter((error) => error.category === category);
  }
  /**
   *    
   */
  getErrorsBySeverity(severity) {
    return this.errors.filter((error) => error.severity === severity);
  }
  /**
   *   
   */
  getErrorStats() {
    const stats = {
      total: this.errors.length,
      byCategory: {},
      bySeverity: {},
      recentErrors: this.errors.slice(-10),
      //  10 
      mostFrequent: []
    };
    Object.values(ErrorCategory).forEach((category) => {
      stats.byCategory[category] = this.getErrorsByCategory(category).length;
    });
    Object.values(ErrorSeverity).forEach((severity) => {
      stats.bySeverity[severity] = this.getErrorsBySeverity(severity).length;
    });
    const sortedErrors = Array.from(this.errorCounts.entries()).sort(([, a], [, b]) => b - a).slice(0, 5).map(([message, count]) => ({ message, count }));
    stats.mostFrequent = sortedErrors;
    return stats;
  }
  /**
   *   
   */
  clearErrors() {
    this.errors = [];
    this.errorCounts.clear();
  }
  /**
   *    JSON
   */
  exportErrors() {
    return JSON.stringify({
      errors: this.errors,
      stats: this.getErrorStats(),
      exportTimestamp: (/* @__PURE__ */ new Date()).toISOString()
    }, null, 2);
  }
  /**
   * ,    
   */
  hasCriticalErrors() {
    return this.errors.some((error) => error.severity === "critical" /* CRITICAL */);
  }
  /**
   *     
   */
  getErrorRecommendations() {
    const recommendations = [];
    const stats = this.getErrorStats();
    if (stats.byCategory["validation" /* VALIDATION */] > 10) {
      recommendations.push("\u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0441\u0442\u044C \u043C\u0430\u0441\u043E\u043A \u0432 \u0444\u0430\u0439\u043B\u0430\u0445");
    }
    if (stats.byCategory["file_operation" /* FILE_OPERATION */] > 5) {
      recommendations.push("\u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430 \u043A \u0444\u0430\u0439\u043B\u0430\u043C \u0438 \u043F\u0430\u043F\u043A\u0430\u043C");
    }
    if (stats.byCategory["parsing" /* PARSING */] > 5) {
      recommendations.push("\u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u043C\u0430\u0441\u043E\u043A \u0432 \u0438\u043C\u0435\u043D\u0430\u0445 \u0444\u0430\u0439\u043B\u043E\u0432");
    }
    if (stats.bySeverity["critical" /* CRITICAL */] > 0) {
      recommendations.push("\u041F\u0435\u0440\u0435\u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u0435 \u043F\u043B\u0430\u0433\u0438\u043D \u0434\u043B\u044F \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0440\u0430\u0431\u043E\u0442\u044B");
    }
    return recommendations;
  }
};
var errorHandler = new ErrorHandler();

// src/ui/debug-panel.ts
var DebugPanel = class extends import_obsidian5.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Debug Panel - Mask Builder" });
    this.createPerformanceSection(contentEl);
    this.createErrorSection(contentEl);
    this.createMaskTestingSection(contentEl);
    this.createActionsSection(contentEl);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createPerformanceSection(containerEl) {
    containerEl.createEl("h3", { text: "Performance Metrics" });
    const metrics = performanceMonitor.getMetrics();
    new import_obsidian5.Setting(containerEl).setName("Plugin Load Time").setDesc(`${metrics.pluginLoadTime.toFixed(2)}ms`).addButton(
      (button) => button.setButtonText("Reset").onClick(() => {
        performanceMonitor.reset();
        this.refresh();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("File Processing Time").setDesc(`${metrics.fileProcessingTime.toFixed(2)}ms`);
    new import_obsidian5.Setting(containerEl).setName("Mask Validation Time").setDesc(`${metrics.maskValidationTime.toFixed(2)}ms`);
    new import_obsidian5.Setting(containerEl).setName("File Operations Time").setDesc(`${metrics.fileOperationsTime.toFixed(2)}ms`);
    new import_obsidian5.Setting(containerEl).setName("Memory Usage").setDesc(`${metrics.memoryUsage.toFixed(2)}MB`);
    new import_obsidian5.Setting(containerEl).setName("Cache Hit Rate").setDesc(`${metrics.cacheHitRate.toFixed(1)}%`);
    new import_obsidian5.Setting(containerEl).setName("Generate Performance Report").setDesc("\u0412\u044B\u0432\u0435\u0441\u0442\u0438 \u043F\u043E\u0434\u0440\u043E\u0431\u043D\u044B\u0439 \u043E\u0442\u0447\u0435\u0442 \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u044C").addButton(
      (button) => button.setButtonText("Generate").onClick(() => {
        performanceMonitor.logPerformanceReport();
        new import_obsidian5.Notice("\u041E\u0442\u0447\u0435\u0442 \u0432\u044B\u0432\u0435\u0434\u0435\u043D \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u044C");
      })
    );
  }
  createErrorSection(containerEl) {
    containerEl.createEl("h3", { text: "Error Statistics" });
    const stats = errorHandler.getErrorStats();
    const recommendations = errorHandler.getErrorRecommendations();
    new import_obsidian5.Setting(containerEl).setName("Total Errors").setDesc(`${stats.total} errors`);
    Object.entries(stats.byCategory).forEach(([category, count]) => {
      if (count > 0) {
        new import_obsidian5.Setting(containerEl).setName(`${category} Errors`).setDesc(`${count} errors`).addButton(
          (button) => button.setButtonText("View").onClick(() => {
            this.showErrorsByCategory(category);
          })
        );
      }
    });
    Object.entries(stats.bySeverity).forEach(([severity, count]) => {
      if (count > 0) {
        new import_obsidian5.Setting(containerEl).setName(`${severity} Severity Errors`).setDesc(`${count} errors`);
      }
    });
    if (recommendations.length > 0) {
      containerEl.createEl("h4", { text: "Recommendations" });
      recommendations.forEach((rec) => {
        containerEl.createEl("p", { text: `\u2022 ${rec}` });
      });
    }
    new import_obsidian5.Setting(containerEl).setName("Clear All Errors").setDesc("\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0435 \u043E\u0448\u0438\u0431\u043A\u0438").addButton(
      (button) => button.setButtonText("Clear").onClick(() => {
        errorHandler.clearErrors();
        this.refresh();
        new import_obsidian5.Notice("\u0412\u0441\u0435 \u043E\u0448\u0438\u0431\u043A\u0438 \u043E\u0447\u0438\u0449\u0435\u043D\u044B");
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Export Error Log").setDesc("\u042D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043B\u043E\u0433 \u043E\u0448\u0438\u0431\u043E\u043A").addButton(
      (button) => button.setButtonText("Export").onClick(() => {
        const errorLog = errorHandler.exportErrors();
        this.copyToClipboard(errorLog);
        new import_obsidian5.Notice("\u041B\u043E\u0433 \u043E\u0448\u0438\u0431\u043E\u043A \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430");
      })
    );
  }
  createMaskTestingSection(containerEl) {
    containerEl.createEl("h3", { text: "Mask Testing" });
    let testMask = "";
    new import_obsidian5.Setting(containerEl).setName("Test Mask").setDesc("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043C\u0430\u0441\u043A\u0443 \u0434\u043B\u044F \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F").addText((text) => {
      text.setPlaceholder("NOTE.ENG.DEV.AC.INT@PROJ-HYDROPILOT");
      text.onChange((value) => {
        testMask = value;
      });
    }).addButton(
      (button) => button.setButtonText("Test").onClick(() => {
        this.testMask(testMask);
      })
    );
  }
  createActionsSection(containerEl) {
    containerEl.createEl("h3", { text: "Debug Actions" });
    new import_obsidian5.Setting(containerEl).setName("Export Performance Metrics").setDesc("\u042D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043C\u0435\u0442\u0440\u0438\u043A\u0438 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438").addButton(
      (button) => button.setButtonText("Export").onClick(() => {
        const metrics = performanceMonitor.exportMetrics();
        this.copyToClipboard(metrics);
        new import_obsidian5.Notice("\u041C\u0435\u0442\u0440\u0438\u043A\u0438 \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u044B \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430");
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Test Error Handling").setDesc("\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0442\u0435\u0441\u0442\u043E\u0432\u0443\u044E \u043E\u0448\u0438\u0431\u043A\u0443").addButton(
      (button) => button.setButtonText("Test").onClick(() => {
        errorHandler.handleError(
          "Test error for debugging",
          "validation" /* VALIDATION */,
          "medium" /* MEDIUM */,
          { test: true }
        );
        this.refresh();
        new import_obsidian5.Notice("\u0422\u0435\u0441\u0442\u043E\u0432\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0430");
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Force Garbage Collection").setDesc("\u041F\u0440\u0438\u043D\u0443\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u0430\u044F \u043E\u0447\u0438\u0441\u0442\u043A\u0430 \u043F\u0430\u043C\u044F\u0442\u0438 (\u0435\u0441\u043B\u0438 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E)").addButton(
      (button) => button.setButtonText("GC").onClick(() => {
        if ("gc" in window) {
          window.gc();
          new import_obsidian5.Notice("Garbage collection \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D");
        } else {
          new import_obsidian5.Notice("Garbage collection \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D");
        }
      })
    );
  }
  showErrorsByCategory(category) {
    const errors = errorHandler.getErrorsByCategory(category);
    const errorModal = new import_obsidian5.Modal(this.app);
    errorModal.titleEl.setText(`Errors - ${category}`);
    const content = errorModal.contentEl;
    content.empty();
    if (errors.length === 0) {
      content.createEl("p", { text: "No errors in this category" });
      return;
    }
    errors.forEach((error, index) => {
      const errorDiv = content.createEl("div", { cls: "error-item" });
      errorDiv.createEl("h4", { text: `Error ${index + 1}` });
      errorDiv.createEl("p", { text: error.message });
      errorDiv.createEl("p", { text: `Severity: ${error.severity}` });
      errorDiv.createEl("p", { text: `Time: ${error.timestamp.toISOString()}` });
      if (error.context) {
        errorDiv.createEl("p", { text: `Context: ${JSON.stringify(error.context)}` });
      }
      content.createEl("hr");
    });
    errorModal.open();
  }
  testMask(maskString) {
    if (!maskString.trim()) {
      new import_obsidian5.Notice("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043C\u0430\u0441\u043A\u0443 \u0434\u043B\u044F \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F");
      return;
    }
    try {
      const parsed = MaskParser.parse(maskString);
      if (!parsed) {
        new import_obsidian5.Notice("\u274C \u041C\u0430\u0441\u043A\u0430 \u043D\u0435 \u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u0430");
        return;
      }
      const validation = MaskParser.validate(parsed);
      const fileName = MaskParser.generateFileName(parsed);
      const filePath = MaskParser.generateFilePath(parsed, "/vault");
      const resultModal = new import_obsidian5.Modal(this.app);
      resultModal.titleEl.setText("Mask Test Results");
      const content = resultModal.contentEl;
      content.empty();
      content.createEl("h3", { text: "Parsing Result" });
      content.createEl("p", { text: `\u2705 \u041C\u0430\u0441\u043A\u0430 \u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E` });
      content.createEl("p", { text: `Entity: ${parsed.entity}` });
      content.createEl("p", { text: `Areas: ${parsed.areas.join(", ")}` });
      content.createEl("p", { text: `Status: ${parsed.status || "N/A"}` });
      content.createEl("p", { text: `Access: ${parsed.access || "N/A"}` });
      content.createEl("p", { text: `Anchor: ${parsed.anchor}` });
      content.createEl("h3", { text: "Validation Result" });
      if (validation.valid) {
        content.createEl("p", { text: "\u2705 \u041C\u0430\u0441\u043A\u0430 \u0432\u0430\u043B\u0438\u0434\u043D\u0430" });
      } else {
        content.createEl("p", { text: "\u274C \u041C\u0430\u0441\u043A\u0430 \u043D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430" });
        validation.errors.forEach((error) => {
          content.createEl("p", { text: `\u2022 ${error}` });
        });
      }
      content.createEl("h3", { text: "Generated Output" });
      content.createEl("p", { text: `File Name: ${fileName}` });
      content.createEl("p", { text: `File Path: ${filePath}` });
      resultModal.open();
    } catch (error) {
      errorHandler.handleError(
        error instanceof Error ? error : new Error(String(error)),
        "parsing" /* PARSING */,
        "medium" /* MEDIUM */,
        { testMask: maskString }
      );
      new import_obsidian5.Notice("\u274C \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0438 \u043C\u0430\u0441\u043A\u0438");
    }
  }
  copyToClipboard(text) {
    navigator.clipboard.writeText(text).catch(() => {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
    });
  }
  refresh() {
    this.onClose();
    this.onOpen();
  }
};

// src/ui/analytics-panel.ts
var import_obsidian6 = require("obsidian");

// src/utils/analytics.ts
var Analytics = class {
  constructor(version, settings) {
    this.version = version;
    this.settings = settings;
    this.events = [];
    this.maxEvents = 1e3;
    this.isEnabled = true;
    this.sessionId = this.generateSessionId();
    this.sessionStart = /* @__PURE__ */ new Date();
  }
  /**
   *   ID 
   */
  generateSessionId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   *   
   */
  track(event, data) {
    if (!this.isEnabled)
      return;
    const analyticsEvent = {
      event,
      timestamp: /* @__PURE__ */ new Date(),
      data: data != null ? data : {},
      sessionId: this.sessionId
    };
    this.events.push(analyticsEvent);
    if (this.events.length > this.maxEvents) {
      this.events.shift();
    }
  }
  /**
   *   
   */
  trackMaskCreated(mask, success) {
    this.track("mask_created", {
      mask,
      success,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *   
   */
  trackMaskValidation(mask, isValid2, errors) {
    this.track("mask_validation", {
      mask,
      isValid: isValid2,
      errors: errors || [],
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *   
   */
  trackFileOperation(operation, fileName, success) {
    this.track("file_operation", {
      operation,
      fileName,
      success,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *   
   */
  trackCommand(command) {
    this.track("command_used", {
      command,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *  
   */
  trackError(error, category, severity) {
    this.track("error_occurred", {
      error,
      category,
      severity,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *   
   */
  trackSettingChange(setting, oldValue, newValue) {
    this.track("setting_changed", {
      setting,
      oldValue,
      newValue,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *  
   */
  trackPerformance(operation, duration) {
    this.track("performance_metric", {
      operation,
      duration,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   *   
   */
  getUsageStats() {
    const stats = {
      sessionId: this.sessionId,
      sessionStart: this.sessionStart,
      sessionDuration: Date.now() - this.sessionStart.getTime(),
      totalEvents: this.events.length,
      eventsByType: {},
      recentEvents: this.events.slice(-10),
      version: this.version
    };
    this.events.forEach((event) => {
      stats.eventsByType[event.event] = (stats.eventsByType[event.event] || 0) + 1;
    });
    return stats;
  }
  /**
   *    
   */
  getMaskAnalytics() {
    const maskEvents = this.events.filter((e) => e.event === "mask_created" || e.event === "mask_validation");
    const maskStats = {
      totalMasksCreated: 0,
      successfulMasks: 0,
      failedMasks: 0,
      totalValidations: 0,
      validMasks: 0,
      invalidMasks: 0,
      commonErrors: {},
      popularMasks: {}
    };
    maskEvents.forEach((event) => {
      var _a, _b, _c, _d;
      if (event.event === "mask_created") {
        maskStats.totalMasksCreated++;
        if ((_a = event.data) == null ? void 0 : _a.success) {
          maskStats.successfulMasks++;
        } else {
          maskStats.failedMasks++;
        }
        const mask = (_b = event.data) == null ? void 0 : _b.mask;
        if (mask) {
          maskStats.popularMasks[mask] = (maskStats.popularMasks[mask] || 0) + 1;
        }
      } else if (event.event === "mask_validation") {
        maskStats.totalValidations++;
        if ((_c = event.data) == null ? void 0 : _c.isValid) {
          maskStats.validMasks++;
        } else {
          maskStats.invalidMasks++;
          const errors = ((_d = event.data) == null ? void 0 : _d.errors) || [];
          errors.forEach((error) => {
            maskStats.commonErrors[error] = (maskStats.commonErrors[error] || 0) + 1;
          });
        }
      }
    });
    return maskStats;
  }
  /**
   *    
   */
  getPerformanceAnalytics() {
    const perfEvents = this.events.filter((e) => e.event === "performance_metric");
    const perfStats = {
      totalOperations: perfEvents.length,
      totalDuration: 0,
      averageDuration: 0,
      operationsByType: {},
      slowestOperations: [],
      fastestOperations: []
    };
    perfEvents.forEach((event) => {
      var _a, _b;
      const operation = (_a = event.data) == null ? void 0 : _a.operation;
      const duration = ((_b = event.data) == null ? void 0 : _b.duration) || 0;
      perfStats.totalDuration += duration;
      if (operation) {
        if (!perfStats.operationsByType[operation]) {
          perfStats.operationsByType[operation] = { count: 0, totalDuration: 0, averageDuration: 0 };
        }
        const stats = perfStats.operationsByType[operation];
        if (stats) {
          stats.count++;
          stats.totalDuration += duration;
        }
      }
    });
    Object.keys(perfStats.operationsByType).forEach((operation) => {
      const stats = perfStats.operationsByType[operation];
      if (stats && stats.count > 0) {
        stats.averageDuration = stats.totalDuration / stats.count;
      }
    });
    const sortedByDuration = perfEvents.map((e) => {
      var _a, _b, _c;
      return { operation: (_b = (_a = e.data) == null ? void 0 : _a.operation) != null ? _b : "unknown", duration: ((_c = e.data) == null ? void 0 : _c.duration) || 0 };
    }).sort((a, b) => b.duration - a.duration);
    perfStats.slowestOperations = sortedByDuration.slice(0, 5);
    perfStats.fastestOperations = sortedByDuration.slice(-5).reverse();
    if (perfStats.totalOperations > 0) {
      perfStats.averageDuration = perfStats.totalDuration / perfStats.totalOperations;
    }
    return perfStats;
  }
  /**
   *    
   */
  getErrorAnalytics() {
    const errorEvents = this.events.filter((e) => e.event === "error_occurred");
    const errorStats = {
      totalErrors: errorEvents.length,
      errorsByCategory: {},
      errorsBySeverity: {},
      mostCommonErrors: {},
      errorTrend: []
    };
    errorEvents.forEach((event) => {
      var _a, _b, _c;
      const category = (_a = event.data) == null ? void 0 : _a.category;
      const severity = (_b = event.data) == null ? void 0 : _b.severity;
      const error = (_c = event.data) == null ? void 0 : _c.error;
      if (category) {
        errorStats.errorsByCategory[category] = (errorStats.errorsByCategory[category] || 0) + 1;
      }
      if (severity) {
        errorStats.errorsBySeverity[severity] = (errorStats.errorsBySeverity[severity] || 0) + 1;
      }
      if (error) {
        errorStats.mostCommonErrors[error] = (errorStats.mostCommonErrors[error] || 0) + 1;
      }
    });
    const errorsByDay = /* @__PURE__ */ new Map();
    errorEvents.forEach((event) => {
      const date = event.timestamp.toISOString().split("T")[0];
      if (date) {
        errorsByDay.set(date, (errorsByDay.get(date) || 0) + 1);
      }
    });
    errorStats.errorTrend = Array.from(errorsByDay.entries()).map(([date, count]) => ({ date, count })).sort((a, b) => a.date.localeCompare(b.date));
    return errorStats;
  }
  /**
   *    
   */
  exportAnalytics() {
    const analyticsData = {
      events: this.events,
      sessionStart: this.sessionStart,
      sessionId: this.sessionId,
      version: this.version,
      settings: this.settings
    };
    return JSON.stringify(analyticsData, null, 2);
  }
  /**
   *   
   */
  clearAnalytics() {
    this.events = [];
    this.sessionId = this.generateSessionId();
    this.sessionStart = /* @__PURE__ */ new Date();
  }
  /**
   * / 
   */
  setEnabled(enabled) {
    this.isEnabled = enabled;
    this.track("analytics_toggled", { enabled });
  }
  /**
   * ,   
   */
  isAnalyticsEnabled() {
    return this.isEnabled;
  }
};
var analytics = null;
function initializeAnalytics(version, settings) {
  analytics = new Analytics(version, settings);
}
function getAnalytics() {
  return analytics;
}

// src/ui/analytics-panel.ts
var AnalyticsPanel = class extends import_obsidian6.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Analytics Dashboard - Mask Builder" });
    const analytics2 = getAnalytics();
    if (!analytics2) {
      contentEl.createEl("p", { text: "Analytics not initialized" });
      return;
    }
    this.createUsageStatsSection(contentEl, analytics2);
    this.createMaskAnalyticsSection(contentEl, analytics2);
    this.createPerformanceAnalyticsSection(contentEl, analytics2);
    this.createErrorAnalyticsSection(contentEl, analytics2);
    this.createActionsSection(contentEl, analytics2);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createUsageStatsSection(containerEl, analytics2) {
    containerEl.createEl("h3", { text: "Usage Statistics" });
    const stats = analytics2.getUsageStats();
    new import_obsidian6.Setting(containerEl).setName("Session ID").setDesc(stats.sessionId);
    new import_obsidian6.Setting(containerEl).setName("Session Start").setDesc(stats.sessionStart.toLocaleString());
    new import_obsidian6.Setting(containerEl).setName("Session Duration").setDesc(this.formatDuration(stats.sessionDuration));
    new import_obsidian6.Setting(containerEl).setName("Total Events").setDesc(`${stats.totalEvents} events`);
    new import_obsidian6.Setting(containerEl).setName("Plugin Version").setDesc(stats.version);
    containerEl.createEl("h4", { text: "Events by Type" });
    Object.entries(stats.eventsByType).forEach(([eventType, count]) => {
      new import_obsidian6.Setting(containerEl).setName(eventType).setDesc(`${count} events`);
    });
  }
  createMaskAnalyticsSection(containerEl, analytics2) {
    containerEl.createEl("h3", { text: "Mask Analytics" });
    const maskStats = analytics2.getMaskAnalytics();
    new import_obsidian6.Setting(containerEl).setName("Total Masks Created").setDesc(`${maskStats.totalMasksCreated} masks`);
    new import_obsidian6.Setting(containerEl).setName("Successful Masks").setDesc(`${maskStats.successfulMasks} masks`);
    new import_obsidian6.Setting(containerEl).setName("Failed Masks").setDesc(`${maskStats.failedMasks} masks`);
    new import_obsidian6.Setting(containerEl).setName("Success Rate").setDesc(maskStats.totalMasksCreated > 0 ? `${(maskStats.successfulMasks / maskStats.totalMasksCreated * 100).toFixed(1)}%` : "N/A");
    new import_obsidian6.Setting(containerEl).setName("Total Validations").setDesc(`${maskStats.totalValidations} validations`);
    new import_obsidian6.Setting(containerEl).setName("Valid Masks").setDesc(`${maskStats.validMasks} masks`);
    new import_obsidian6.Setting(containerEl).setName("Invalid Masks").setDesc(`${maskStats.invalidMasks} masks`);
    new import_obsidian6.Setting(containerEl).setName("Validation Rate").setDesc(maskStats.totalValidations > 0 ? `${(maskStats.validMasks / maskStats.totalValidations * 100).toFixed(1)}%` : "N/A");
    if (Object.keys(maskStats.popularMasks).length > 0) {
      containerEl.createEl("h4", { text: "Popular Masks" });
      const sortedMasks = Object.entries(maskStats.popularMasks).sort(([, a], [, b]) => b - a).slice(0, 5);
      sortedMasks.forEach(([mask, count]) => {
        new import_obsidian6.Setting(containerEl).setName(mask).setDesc(`Used ${count} times`);
      });
    }
    if (Object.keys(maskStats.commonErrors).length > 0) {
      containerEl.createEl("h4", { text: "Common Validation Errors" });
      const sortedErrors = Object.entries(maskStats.commonErrors).sort(([, a], [, b]) => b - a).slice(0, 5);
      sortedErrors.forEach(([error, count]) => {
        new import_obsidian6.Setting(containerEl).setName(error).setDesc(`Occurred ${count} times`);
      });
    }
  }
  createPerformanceAnalyticsSection(containerEl, analytics2) {
    containerEl.createEl("h3", { text: "Performance Analytics" });
    const perfStats = analytics2.getPerformanceAnalytics();
    new import_obsidian6.Setting(containerEl).setName("Total Operations").setDesc(`${perfStats.totalOperations} operations`);
    new import_obsidian6.Setting(containerEl).setName("Average Duration").setDesc(perfStats.averageDuration > 0 ? `${perfStats.averageDuration.toFixed(2)}ms` : "N/A");
    if (Object.keys(perfStats.operationsByType).length > 0) {
      containerEl.createEl("h4", { text: "Operations by Type" });
      Object.entries(perfStats.operationsByType).forEach(([operation, stats]) => {
        new import_obsidian6.Setting(containerEl).setName(operation).setDesc(`${stats.count} operations, avg: ${stats.averageDuration.toFixed(2)}ms`);
      });
    }
    if (perfStats.slowestOperations.length > 0) {
      containerEl.createEl("h4", { text: "Slowest Operations" });
      perfStats.slowestOperations.forEach((op) => {
        new import_obsidian6.Setting(containerEl).setName(op.operation).setDesc(`${op.duration.toFixed(2)}ms`);
      });
    }
    if (perfStats.fastestOperations.length > 0) {
      containerEl.createEl("h4", { text: "Fastest Operations" });
      perfStats.fastestOperations.forEach((op) => {
        new import_obsidian6.Setting(containerEl).setName(op.operation).setDesc(`${op.duration.toFixed(2)}ms`);
      });
    }
  }
  createErrorAnalyticsSection(containerEl, analytics2) {
    containerEl.createEl("h3", { text: "Error Analytics" });
    const errorStats = analytics2.getErrorAnalytics();
    new import_obsidian6.Setting(containerEl).setName("Total Errors").setDesc(`${errorStats.totalErrors} errors`);
    if (Object.keys(errorStats.errorsByCategory).length > 0) {
      containerEl.createEl("h4", { text: "Errors by Category" });
      Object.entries(errorStats.errorsByCategory).forEach(([category, count]) => {
        new import_obsidian6.Setting(containerEl).setName(category).setDesc(`${count} errors`);
      });
    }
    if (Object.keys(errorStats.errorsBySeverity).length > 0) {
      containerEl.createEl("h4", { text: "Errors by Severity" });
      Object.entries(errorStats.errorsBySeverity).forEach(([severity, count]) => {
        new import_obsidian6.Setting(containerEl).setName(severity).setDesc(`${count} errors`);
      });
    }
    if (Object.keys(errorStats.mostCommonErrors).length > 0) {
      containerEl.createEl("h4", { text: "Most Common Errors" });
      const sortedErrors = Object.entries(errorStats.mostCommonErrors).sort(([, a], [, b]) => b - a).slice(0, 5);
      sortedErrors.forEach(([error, count]) => {
        new import_obsidian6.Setting(containerEl).setName(error).setDesc(`Occurred ${count} times`);
      });
    }
    if (errorStats.errorTrend.length > 0) {
      containerEl.createEl("h4", { text: "Error Trend (Last 7 Days)" });
      const recentTrend = errorStats.errorTrend.slice(-7);
      recentTrend.forEach((day) => {
        new import_obsidian6.Setting(containerEl).setName(day.date).setDesc(`${day.count} errors`);
      });
    }
  }
  createActionsSection(containerEl, analytics2) {
    containerEl.createEl("h3", { text: "Analytics Actions" });
    new import_obsidian6.Setting(containerEl).setName("Export Analytics Data").setDesc("Export all analytics data as JSON").addButton(
      (button) => button.setButtonText("Export").onClick(() => {
        const data = analytics2.exportAnalytics();
        this.copyToClipboard(data);
        new import_obsidian6.Notice("Analytics data exported to clipboard");
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Clear Analytics Data").setDesc("Clear all analytics data").addButton(
      (button) => button.setButtonText("Clear").onClick(() => {
        analytics2.clearAnalytics();
        this.refresh();
        new import_obsidian6.Notice("Analytics data cleared");
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Toggle Analytics").setDesc(analytics2.isAnalyticsEnabled() ? "Analytics is enabled" : "Analytics is disabled").addToggle(
      (toggle) => toggle.setValue(analytics2.isAnalyticsEnabled()).onChange((value) => {
        analytics2.setEnabled(value);
        this.refresh();
        new import_obsidian6.Notice(`Analytics ${value ? "enabled" : "disabled"}`);
      })
    );
  }
  formatDuration(ms) {
    const seconds = Math.floor(ms / 1e3);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }
  copyToClipboard(text) {
    navigator.clipboard.writeText(text).catch(() => {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
    });
  }
  refresh() {
    this.onClose();
    this.onOpen();
  }
};

// src/utils/file-manager.ts
var import_obsidian7 = require("obsidian");
var FileManager = class {
  constructor(app) {
    this.cache = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   *     
   */
  async createFileFromMask(mask, content = "", template) {
    try {
      const fileName = this.generateFileName(mask);
      const filePath = this.generateFilePath(mask);
      const fullPath = `${filePath}${fileName}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
      if (existingFile) {
        new import_obsidian7.Notice(`\u0424\u0430\u0439\u043B ${fileName} \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442`);
        return null;
      }
      await this.ensureFolderExists(filePath);
      const finalContent = await this.prepareContent(content, template, mask);
      const file = await this.app.vault.create(fullPath, finalContent);
      new import_obsidian7.Notice(`\u0421\u043E\u0437\u0434\u0430\u043D \u0444\u0430\u0439\u043B: ${fileName}`);
      return file;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430:", error);
      new import_obsidian7.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C.");
      return null;
    }
  }
  /**
   *      
   */
  async moveFileByMask(file, mask) {
    try {
      const newPath = this.generateFilePath(mask);
      const newFileName = this.generateFileName(mask);
      const fullNewPath = `${newPath}${newFileName}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(fullNewPath);
      if (existingFile) {
        new import_obsidian7.Notice(`\u0424\u0430\u0439\u043B ${newFileName} \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0446\u0435\u043B\u0435\u0432\u043E\u0439 \u043F\u0430\u043F\u043A\u0435`);
        return false;
      }
      await this.ensureFolderExists(newPath);
      await this.app.fileManager.renameFile(file, fullNewPath);
      new import_obsidian7.Notice(`\u0424\u0430\u0439\u043B \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D: ${newFileName}`);
      return true;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430:", error);
      new import_obsidian7.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0435\u0440\u0435\u043C\u0435\u0449\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C.");
      return false;
    }
  }
  /**
   *      
   */
  async updateFrontmatter(file, mask) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = this.generateFrontmatter(mask);
      const updatedContent = this.updateContentFrontmatter(content, frontmatter);
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440\u0430:", error);
      return false;
    }
  }
  /**
   *      
   */
  generateFileName(mask) {
    const parts = [mask.entity];
    if (mask.areas && mask.areas.length > 0) {
      parts.push(...mask.areas);
    }
    if (mask.status) {
      parts.push(mask.status);
    }
    if (mask.access) {
      parts.push(mask.access);
    }
    if (mask.format) {
      parts.push(mask.format);
    }
    if (mask.references && mask.references.length > 0) {
      parts.push(`+${mask.references.join(",")}`);
    }
    if (mask.anchor) {
      parts.push(`@${mask.anchor}`);
    }
    return parts.join(".");
  }
  /**
   *    
   */
  generateFilePath(mask) {
    if (!mask.anchor) {
      return `0_INBOX/`;
    }
    const anchorType = this.getAnchorType(mask.anchor);
    if (anchorType === "project") {
      return `1_PROJECTS/${mask.anchor}/notes/`;
    } else if (anchorType === "category") {
      const isKB = mask.areas && mask.areas.includes("KB") || mask.anchor === "CAT-KB";
      if (isKB) {
        return `2_CATEGORIES/${mask.anchor}/notes/`;
      }
      return `2_CATEGORIES/${mask.anchor}/notes/`;
    }
    return `0_INBOX/`;
  }
  /**
   *   
   */
  getAnchorType(anchor) {
    if (anchor.startsWith("PROJ-")) {
      return "project";
    } else if (anchor.startsWith("CAT-")) {
      return "category";
    }
    return "unknown";
  }
  /**
   *      
   */
  async ensureFolderExists(filePath) {
    const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
    const normalizedPath = (0, import_obsidian7.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder || !(folder instanceof import_obsidian7.TFolder)) {
      await this.app.vault.createFolder(normalizedPath);
    }
  }
  /**
   *   
   */
  async prepareContent(content, template, mask) {
    let finalContent = content;
    if (template) {
      const templateFile = this.app.vault.getAbstractFileByPath(template);
      if (templateFile instanceof import_obsidian7.TFile) {
        const templateContent = await this.app.vault.read(templateFile);
        finalContent = templateContent + "\n\n" + content;
      }
    }
    if (mask) {
      const frontmatter = this.generateFrontmatter(mask);
      finalContent = frontmatter + "\n\n" + finalContent;
    }
    return finalContent;
  }
  /**
   *     
   */
  generateFrontmatter(mask) {
    const frontmatter = {
      created: (/* @__PURE__ */ new Date()).toISOString(),
      mask: this.generateFileName(mask),
      entity: mask.entity,
      areas: mask.areas,
      anchor: mask.anchor
    };
    if (mask.status)
      frontmatter.status = mask.status;
    if (mask.access)
      frontmatter.access = mask.access;
    if (mask.format)
      frontmatter.format = mask.format;
    if (mask.references)
      frontmatter.references = mask.references;
    if (mask.areas.includes("KB") || mask.anchor === "CAT-KB") {
      frontmatter.kb = true;
    }
    return `---
${Object.entries(frontmatter).map(([key, value]) => `${key}: ${JSON.stringify(value)}`).join("\n")}
---`;
  }
  /**
   *     
   */
  updateContentFrontmatter(content, newFrontmatter) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = content.match(frontmatterRegex);
    if (match) {
      return content.replace(frontmatterRegex, newFrontmatter + "\n");
    } else {
      return newFrontmatter + "\n\n" + content;
    }
  }
  /**
   *  
   */
  clearCache() {
    this.cache.clear();
  }
};

// src/ui/ribbon-menu.ts
var import_obsidian9 = require("obsidian");

// src/ui/ribbon-settings-modal.ts
var import_obsidian8 = require("obsidian");
var RibbonSettingsModal = class extends import_obsidian8.Modal {
  constructor(app, options) {
    super(app);
    this.availableIcons = [
      "edit",
      "edit-3",
      "upload",
      "plus",
      "file-plus",
      "save",
      "download",
      "settings",
      "search",
      "link",
      "tag",
      "calendar",
      "star",
      "heart",
      "bookmark",
      "share",
      "refresh",
      "trash",
      "check",
      "x",
      "book-open",
      "folder",
      "check-square"
    ];
    this.options = options;
    this.actions = JSON.parse(JSON.stringify(options.actions));
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0433\u043E \u043C\u0435\u043D\u044E" });
    contentEl.createEl("p", {
      text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u0442\u0435 \u0437\u043D\u0430\u0447\u043A\u0438 \u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0434\u043B\u044F \u043B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0433\u043E \u043C\u0435\u043D\u044E. \u041F\u0435\u0440\u0435\u0442\u0430\u0441\u043A\u0438\u0432\u0430\u0439\u0442\u0435 \u0437\u043D\u0430\u0447\u043A\u0438 \u0434\u043B\u044F \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u043F\u043E\u0440\u044F\u0434\u043A\u0430.",
      cls: "setting-item-description"
    });
    this.createActionsList(contentEl);
    this.createButtons(contentEl);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   *   
   */
  createActionsList(containerEl) {
    const actionsContainer = containerEl.createEl("div", { cls: "ribbon-actions-container" });
    this.actions.forEach((action, index) => {
      this.createActionSetting(actionsContainer, action, index);
    });
    const addButton = new import_obsidian8.ButtonComponent(actionsContainer).setButtonText("+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435").setClass("mod-cta").onClick(() => this.addNewAction());
  }
  /**
   *    
   */
  createActionSetting(containerEl, action, index) {
    const actionContainer = containerEl.createEl("div", { cls: "ribbon-action-setting" });
    const header = actionContainer.createEl("div", { cls: "action-header" });
    header.createEl("h4", { text: `\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ${index + 1}` });
    const deleteButton = new import_obsidian8.ButtonComponent(header).setButtonText("\xD7").setClass("mod-warning").onClick(() => this.removeAction(index));
    const settingsContainer = actionContainer.createEl("div", { cls: "action-settings" });
    new import_obsidian8.Setting(settingsContainer).setName("\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435").setDesc("\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u043C\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F").addText((text) => {
      text.setValue(action.name);
      text.onChange((value) => {
        action.name = value;
      });
    });
    new import_obsidian8.Setting(settingsContainer).setName("\u0418\u043A\u043E\u043D\u043A\u0430").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0443 \u0434\u043B\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F").addDropdown((dropdown) => {
      this.availableIcons.forEach((icon) => {
        dropdown.addOption(icon, icon);
      });
      dropdown.setValue(action.icon);
      dropdown.onChange((value) => {
        action.icon = value;
        this.updateIconPreview(actionContainer, value);
      });
    });
    this.createIconPreview(settingsContainer, action.icon);
    new import_obsidian8.Setting(settingsContainer).setName("\u0422\u0438\u043F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0438\u043F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F").addDropdown((dropdown) => {
      dropdown.addOption("format", "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435").addOption("api", "API").addOption("create", "\u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435").addOption("custom", "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0435");
      dropdown.setValue(action.action);
      dropdown.onChange((value) => {
        action.action = value;
        this.updateCustomActionField(settingsContainer, action);
      });
    });
    if (action.action === "custom") {
      this.createCustomActionField(settingsContainer, action);
    }
    new import_obsidian8.Setting(settingsContainer).setName("\u041F\u043E\u0440\u044F\u0434\u043E\u043A").setDesc("\u041F\u043E\u0440\u044F\u0434\u043E\u043A \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F (\u043C\u0435\u043D\u044C\u0448\u0435 = \u0432\u044B\u0448\u0435)").addSlider((slider) => {
      slider.setLimits(1, 10, 1).setValue(action.order).setDynamicTooltip().onChange((value) => {
        action.order = value;
      });
    });
    new import_obsidian8.Setting(settingsContainer).setName("\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043E").setDesc("\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043B\u0438 \u044D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435").addToggle((toggle) => {
      toggle.setValue(action.enabled);
      toggle.onChange((value) => {
        action.enabled = value;
      });
    });
    if (index < this.actions.length - 1) {
      actionContainer.createEl("hr");
    }
  }
  /**
   *    
   */
  createIconPreview(containerEl, iconName) {
    const previewContainer = containerEl.createEl("div", { cls: "icon-preview-container" });
    const preview = previewContainer.createEl("div", { cls: "icon-preview" });
    preview.innerHTML = this.getIconSvg(iconName);
    previewContainer.createEl("span", {
      text: `\u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440: ${iconName}`,
      cls: "icon-preview-text"
    });
  }
  /**
   *    
   */
  updateIconPreview(containerEl, iconName) {
    const preview = containerEl.querySelector(".icon-preview");
    if (preview) {
      preview.innerHTML = this.getIconSvg(iconName);
    }
    const text = containerEl.querySelector(".icon-preview-text");
    if (text) {
      text.textContent = `\u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440: ${iconName}`;
    }
  }
  /**
   *     
   */
  createCustomActionField(containerEl, action) {
    const existingField = containerEl.querySelector(".custom-action-field");
    if (existingField)
      return;
    const customField = containerEl.createEl("div", { cls: "custom-action-field" });
    new import_obsidian8.Setting(customField).setName("\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435").setDesc("\u0418\u0434\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0442\u043E\u0440 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0433\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F").addText((text) => {
      text.setValue(action.customAction || "");
      text.onChange((value) => {
        action.customAction = value;
      });
    });
  }
  /**
   *    
   */
  updateCustomActionField(containerEl, action) {
    const existingField = containerEl.querySelector(".custom-action-field");
    if (existingField) {
      existingField.remove();
    }
    if (action.action === "custom") {
      this.createCustomActionField(containerEl, action);
    }
  }
  /**
   *   
   */
  addNewAction() {
    const newAction = {
      id: `action-${Date.now()}`,
      name: "\u041D\u043E\u0432\u043E\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435",
      icon: "edit",
      action: "custom",
      enabled: true,
      order: this.actions.length + 1,
      customAction: "newAction"
    };
    this.actions.push(newAction);
    this.refreshActionsList();
  }
  /**
   *  
   */
  removeAction(index) {
    this.actions.splice(index, 1);
    this.actions.forEach((action, i) => {
      action.order = i + 1;
    });
    this.refreshActionsList();
  }
  /**
   *   
   */
  refreshActionsList() {
    const actionsContainer = this.contentEl.querySelector(".ribbon-actions-container");
    if (actionsContainer) {
      actionsContainer.empty();
      this.createActionsList(actionsContainer);
    }
  }
  /**
   *  
   */
  createButtons(containerEl) {
    const buttonContainer = containerEl.createEl("div", { cls: "button-container" });
    const saveButton = new import_obsidian8.ButtonComponent(buttonContainer).setButtonText("\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C").setClass("mod-cta").onClick(() => this.saveSettings());
    const cancelButton = new import_obsidian8.ButtonComponent(buttonContainer).setButtonText("\u041E\u0442\u043C\u0435\u043D\u0430").onClick(() => this.close());
    const resetButton = new import_obsidian8.ButtonComponent(buttonContainer).setButtonText("\u0421\u0431\u0440\u043E\u0441").setClass("mod-warning").onClick(() => this.resetToDefaults());
  }
  /**
   *  
   */
  saveSettings() {
    try {
      const validActions = this.actions.filter((action) => {
        var _a;
        if (!action.name.trim()) {
          new import_obsidian8.Notice(`\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ${action.id}: \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0443\u0441\u0442\u044B\u043C`);
          return false;
        }
        if (action.action === "custom" && !((_a = action.customAction) == null ? void 0 : _a.trim())) {
          new import_obsidian8.Notice(`\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ${action.name}: \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435`);
          return false;
        }
        return true;
      });
      if (validActions.length === 0) {
        new import_obsidian8.Notice("\u0414\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u0445\u043E\u0442\u044F \u0431\u044B \u043E\u0434\u043D\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435");
        return;
      }
      this.options.onSave(validActions);
      new import_obsidian8.Notice("\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B");
      this.close();
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A:", error);
      new import_obsidian8.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A");
    }
  }
  /**
   *      
   */
  resetToDefaults() {
    this.actions = [
      {
        id: "format-note",
        name: "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
        icon: "edit",
        action: "format",
        enabled: true,
        order: 1
      },
      {
        id: "send-api",
        name: "\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0432 API",
        icon: "upload",
        action: "api",
        enabled: true,
        order: 2
      },
      {
        id: "create-note",
        name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443",
        icon: "plus",
        action: "create",
        enabled: true,
        order: 3
      }
    ];
    this.refreshActionsList();
    new import_obsidian8.Notice("\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0441\u0431\u0440\u043E\u0448\u0435\u043D\u044B \u043A \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F\u043C \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E");
  }
  /**
   *  SVG   
   */
  getIconSvg(iconName) {
    const icons = {
      "edit": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>',
      "upload": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7,10 12,15 17,10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
      "plus": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>',
      "save": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17,21 17,13 7,13 7,21"></polyline><polyline points="7,3 7,8 15,8"></polyline></svg>',
      "download": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7,10 12,15 17,10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
      "settings": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>',
      "search": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>',
      "link": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>',
      "tag": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>',
      "calendar": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>',
      "star": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon></svg>',
      "heart": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>',
      "bookmark": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>',
      "share": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>',
      "refresh": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23,4 23,10 17,10"></polyline><polyline points="1,20 1,14 7,14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>',
      "trash": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3,6 5,6 21,6"></polyline><path d="M19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path></svg>',
      "check": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>',
      "x": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
      "edit-3": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path><path d="M8 12h8"></path><path d="M8 16h6"></path></svg>',
      "file-plus": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14,2 14,8 20,8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>',
      "book-open": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>',
      "folder": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 13.07 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"></path></svg>',
      "check-square": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"></path><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>'
    };
    if (iconName && icons[iconName]) {
      return icons[iconName];
    }
    return icons["edit"];
  }
};

// src/ui/ribbon-menu.ts
var RibbonMenu = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.actionHandlers = /* @__PURE__ */ new Map();
    this.setupDefaultHandlers();
  }
  /**
   *   
   */
  create(container) {
    this.container = container;
    const ribbonContainer = container.createEl("div", {
      cls: "mask-builder-ribbon-menu"
    });
    const header = ribbonContainer.createEl("div", {
      cls: "ribbon-header"
    });
    header.createEl("h4", { text: "\u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F" });
    const iconsContainer = ribbonContainer.createEl("div", {
      cls: "ribbon-icons"
    });
    const sortedActions = [...this.options.actions].filter((action) => action.enabled).sort((a, b) => a.order - b.order);
    sortedActions.forEach((action) => {
      this.createActionIcon(iconsContainer, action);
    });
    this.createSettingsButton(ribbonContainer);
  }
  /**
   *   
   */
  createActionIcon(container, action) {
    console.log("\u0421\u043E\u0437\u0434\u0430\u0435\u043C \u0437\u043D\u0430\u0447\u043E\u043A \u0434\u043B\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F:", action.id, action.name, action.icon);
    const iconContainer = container.createEl("div", {
      cls: "ribbon-action-icon"
    });
    console.log("\u0421\u043E\u0437\u0434\u0430\u043D iconContainer:", iconContainer);
    const icon = iconContainer.createEl("div", {
      cls: "ribbon-icon"
    });
    const iconSvg = this.getIconSvg(action.icon);
    console.log("SVG \u0434\u043B\u044F \u0438\u043A\u043E\u043D\u043A\u0438", action.icon, ":", iconSvg);
    icon.innerHTML = iconSvg;
    iconContainer.setAttribute("title", action.name);
    iconContainer.addEventListener("click", () => {
      console.log("\u041A\u043B\u0438\u043A \u043F\u043E \u0437\u043D\u0430\u0447\u043A\u0443 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F:", action.id);
      this.handleAction(action);
    });
    iconContainer.addEventListener("mouseenter", () => {
      iconContainer.addClass("hover");
    });
    iconContainer.addEventListener("mouseleave", () => {
      iconContainer.removeClass("hover");
    });
    console.log("\u0417\u043D\u0430\u0447\u043E\u043A \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0441\u043E\u0437\u0434\u0430\u043D \u0443\u0441\u043F\u0435\u0448\u043D\u043E:", action.id);
  }
  /**
   *   
   */
  createSettingsButton(container) {
    const settingsButton = container.createEl("div", {
      cls: "ribbon-settings-button"
    });
    settingsButton.innerHTML = this.getIconSvg("settings");
    settingsButton.setAttribute("title", "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0433\u043E \u043C\u0435\u043D\u044E");
    settingsButton.addEventListener("click", () => {
      this.showSettingsModal();
    });
  }
  /**
   *  
   */
  handleAction(action) {
    try {
      const context = this.getActionContext();
      this.options.onAction(action, context);
      const handler = this.actionHandlers.get(action.action);
      if (handler) {
        handler(context);
      }
      new import_obsidian9.Notice(`\u0412\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u043E: ${action.name}`);
    } catch (error) {
      this.handleError(error, "handleAction");
    }
  }
  /**
   *    
   */
  getActionContext() {
    return {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      plugin: "mask-builder",
      version: "1.0.0"
    };
  }
  /**
   *    
   */
  setupDefaultHandlers() {
    this.actionHandlers.set("format", (context) => {
      this.handleFormatAction(context);
    });
    this.actionHandlers.set("api", (context) => {
      this.handleApiAction(context);
    });
    this.actionHandlers.set("create", (context) => {
      this.handleCreateAction(context);
    });
  }
  /**
   *   
   */
  handleFormatAction(context) {
    console.log("\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438:", context);
  }
  /**
   *   API
   */
  handleApiAction(context) {
    console.log("\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0432 API:", context);
  }
  /**
   *   
   */
  handleCreateAction(context) {
    console.log("\u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438:", context);
  }
  /**
   *    
   */
  showSettingsModal() {
    const settingsModal = new RibbonSettingsModal(this.app, {
      actions: this.options.actions,
      onSave: (actions) => {
        this.options.actions = actions;
        this.updateActions(actions);
        if (this.options.onSettingsChange) {
          this.options.onSettingsChange(actions);
        }
        new import_obsidian9.Notice("\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0433\u043E \u043C\u0435\u043D\u044E \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u044B");
      }
    });
    settingsModal.open();
  }
  /**
   *  SVG   
   */
  getIconSvg(iconName) {
    const icons = {
      "edit": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>',
      "edit-3": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path><path d="M8 12h8"></path><path d="M8 16h6"></path></svg>',
      "upload": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7,10 12,15 17,10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
      "plus": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>',
      "file-plus": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14,2 14,8 20,8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>',
      "save": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17,21 17,13 7,13 7,21"></polyline><polyline points="7,3 7,8 15,8"></polyline></svg>',
      "download": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7,10 12,15 17,10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
      "settings": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>',
      "search": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>',
      "link": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>',
      "tag": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>',
      "calendar": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>',
      "book-open": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>',
      "folder": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 13.07 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"></path></svg>',
      "check-square": '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"></path><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>'
    };
    const iconSvg = icons[iconName];
    if (iconSvg) {
      console.log("\u041D\u0430\u0439\u0434\u0435\u043D\u0430 SVG \u0438\u043A\u043E\u043D\u043A\u0430 \u0434\u043B\u044F", iconName);
      return iconSvg;
    } else {
      console.warn("SVG \u0438\u043A\u043E\u043D\u043A\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430 \u0434\u043B\u044F", iconName, "\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u0438\u043A\u043E\u043D\u043A\u0438:", Object.keys(icons));
      return icons["edit"] || '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>';
    }
  }
  /**
   *    
   */
  updateActions(actions) {
    this.options.actions = actions;
    if (this.container) {
      this.container.empty();
      this.create(this.container);
    }
  }
  /**
   * / 
   */
  setVisible(visible) {
    if (this.container) {
      this.container.style.display = visible ? "block" : "none";
    }
  }
  /**
   *  
   */
  destroy() {
    if (this.container) {
      this.container.empty();
    }
    this.actionHandlers.clear();
  }
  handleError(error, context) {
    console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0432 RibbonMenu (${context}):`, error);
    if (error instanceof Error) {
      new import_obsidian9.Notice(`\u041E\u0448\u0438\u0431\u043A\u0430: ${error.message}`);
    } else {
      new import_obsidian9.Notice(`\u041E\u0448\u0438\u0431\u043A\u0430: ${String(error)}`);
    }
  }
};

// src/main.ts
function debounce(func, wait, immediate = false) {
  let timeout = null;
  return function executedFunction(...args) {
    const later = () => {
      timeout = null;
      if (!immediate)
        func(...args);
    };
    const callNow = immediate && !timeout;
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func(...args);
  };
}
var MaskBuilderPlugin = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    try {
      performanceMonitor.startTimer("pluginLoad");
      console.log("Loading Mask Builder plugin...");
      this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
      this.settings = migrateSettings(this.settings);
      initializeAnalytics("1.0.0", this.settings);
      this.fileManager = new FileManager(this.app);
      this.entityFinder = new EntityFinder(this.app);
      this.debouncedProcessFile = debounce(
        (file) => this.processFile(file),
        this.settings.debounceDelay,
        true
      );
      this.registerCommands();
      this.addSettingTab(new MaskBuilderSettingTab(this.app, this));
      this.registerEventHandlers();
      this.createRibbonMenu();
      this.registerEvent(
        this.app.workspace.on("layout-change", () => {
          this.updateRibbonMenuPosition();
        })
      );
      setTimeout(() => {
        if (!this.ribbonContainer || !this.ribbonContainer.parentNode) {
          console.log("\u{1F50D} \u041B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0435 \u043C\u0435\u043D\u044E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E, \u0441\u043E\u0437\u0434\u0430\u0435\u043C \u0441 \u0437\u0430\u0434\u0435\u0440\u0436\u043A\u043E\u0439...");
          this.createRibbonMenu();
        }
      }, 1e3);
      performanceMonitor.endTimer("pluginLoad");
      console.log("Mask Builder plugin loaded successfully");
    } catch (error) {
      errorHandler.handleCriticalError(
        error instanceof Error ? error : new Error(String(error)),
        { operation: "pluginLoad" }
      );
      throw error;
    }
  }
  onunload() {
    console.log("Unloading Mask Builder plugin");
    try {
      if (this.ribbonMenu) {
        this.ribbonMenu.destroy();
      }
      if (this.ribbonContainer && this.ribbonContainer.parentNode) {
        this.ribbonContainer.parentNode.removeChild(this.ribbonContainer);
      }
      this.fileManager.clearCache();
      performanceMonitor.logPerformanceReport();
      console.log("Mask Builder plugin unloaded");
    } catch (error) {
      errorHandler.handleError(
        error instanceof Error ? error : new Error(String(error)),
        "unknown" /* UNKNOWN */,
        "medium" /* MEDIUM */,
        { operation: "pluginUnload" }
      );
    }
  }
  registerCommands() {
    this.addCommand({
      id: "open-mask-builder",
      name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C Mask Builder",
      callback: () => this.openMaskBuilder(),
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "M" }]
    });
    this.addCommand({
      id: "create-note-from-mask",
      name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 \u043F\u043E \u043C\u0430\u0441\u043A\u0435",
      callback: () => this.createNoteFromMask()
    });
    this.addCommand({
      id: "validate-current-file-mask",
      name: "\u0412\u0430\u043B\u0438\u0434\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043C\u0430\u0441\u043A\u0443 \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0444\u0430\u0439\u043B\u0430",
      callback: () => this.validateCurrentFileMask()
    });
    this.addCommand({
      id: "move-file-by-mask",
      name: "\u041F\u0435\u0440\u0435\u043C\u0435\u0441\u0442\u0438\u0442\u044C \u0444\u0430\u0439\u043B \u043F\u043E \u043C\u0430\u0441\u043A\u0435",
      callback: () => this.moveCurrentFileByMask()
    });
    if (this.settings.enabled) {
      this.addCommand({
        id: "open-debug-panel",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043D\u0435\u043B\u044C \u043E\u0442\u043B\u0430\u0434\u043A\u0438",
        callback: () => this.openDebugPanel(),
        hotkeys: [{ modifiers: ["Mod", "Shift", "Alt"], key: "D" }]
      });
      this.addCommand({
        id: "open-analytics-panel",
        name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043D\u0435\u043B\u044C \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0438",
        callback: () => this.openAnalyticsPanel(),
        hotkeys: [{ modifiers: ["Mod", "Shift", "Alt"], key: "A" }]
      });
      this.addCommand({
        id: "force-create-ribbon-menu",
        name: "\u041F\u0440\u0438\u043D\u0443\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0441\u043E\u0437\u0434\u0430\u0442\u044C \u043B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0435 \u043C\u0435\u043D\u044E",
        callback: () => this.forceCreateRibbonMenu(),
        hotkeys: [{ modifiers: ["Mod", "Shift", "Alt"], key: "R" }]
      });
      this.addCommand({
        id: "check-ribbon-menu-status",
        name: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0435 \u043B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0433\u043E \u043C\u0435\u043D\u044E",
        callback: () => this.checkRibbonMenuStatus(),
        hotkeys: [{ modifiers: ["Mod", "Shift", "Alt"], key: "S" }]
      });
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian10.TFile && this.settings.autoCategorize) {
          this.debouncedProcessFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian10.TFile && this.settings.autoCategorize) {
          this.debouncedProcessFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian10.TFile && this.settings.autoCategorize) {
          this.checkFrontmatterChanges(file);
        }
      })
    );
  }
  async processFile(file) {
    var _a;
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (frontmatter) {
        const maskMatch = frontmatter.match(/^mask:\s*(.+)$/m);
        if (maskMatch && maskMatch[1]) {
          const maskString = maskMatch[1].replace(/['"]/g, "");
          const mask = MaskParser.parse(maskString);
          if (!mask)
            return;
          if (this.settings.maskValidation) {
            performanceMonitor.startTimer("maskValidation");
            const validation = MaskParser.validate(mask);
            performanceMonitor.endTimer("maskValidation");
            const analytics3 = getAnalytics();
            if (analytics3) {
              analytics3.trackMaskValidation(file.name, validation.valid, validation.errors);
            }
            if (!validation.valid) {
              errorHandler.handleValidationError(
                `Invalid mask in file ${file.name}: ${validation.errors.join(", ")}`,
                { fileName: file.name, mask, errors: validation.errors }
              );
              performanceMonitor.endTimer("fileProcessing");
              return;
            }
          }
          performanceMonitor.startTimer("fileOperations");
          await this.fileManager.updateFrontmatter(file, mask);
          performanceMonitor.endTimer("fileOperations");
          const analytics2 = getAnalytics();
          if (analytics2) {
            analytics2.trackFileOperation("updateFrontmatter", file.name, true);
          }
          if (this.settings.autoCategorize) {
            await this.autoMoveFile(file, mask);
          }
          performanceMonitor.endTimer("fileProcessing");
        }
      }
    } catch (error) {
      errorHandler.handleError(
        error instanceof Error ? error : new Error(String(error)),
        "file_operation" /* FILE_OPERATION */,
        "medium" /* MEDIUM */,
        { file: file.path }
      );
    }
  }
  extractMaskFromFileName(fileName) {
    const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
    return MaskParser.parse(nameWithoutExt);
  }
  async autoMoveFile(file, mask) {
    try {
      const currentPath = file.path;
      const targetPath = MaskParser.generateFilePath(mask, "");
      const fileName = MaskParser.generateFileName(mask);
      const fullTargetPath = `${targetPath}${fileName}.md`;
      if (currentPath === fullTargetPath)
        return;
      await this.fileManager.moveFileByMask(file, mask);
      const analytics2 = getAnalytics();
      if (analytics2) {
        analytics2.trackFileOperation("moveFile", file.name, true);
      }
    } catch (error) {
      errorHandler.handleFileOperationError(
        error instanceof Error ? error : new Error(String(error)),
        { fileName: file.name, operation: "autoMoveFile", mask }
      );
      const analytics2 = getAnalytics();
      if (analytics2) {
        analytics2.trackFileOperation("moveFile", file.name, false);
      }
    }
  }
  async checkFrontmatterChanges(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!frontmatterMatch)
        return;
      const frontmatter = frontmatterMatch[1];
      if (!frontmatter)
        return;
      const maskMatch = frontmatter.match(/^mask:\s*(.+)$/m);
      if (!maskMatch || !maskMatch[1])
        return;
      const maskString = maskMatch[1].replace(/['"]/g, "");
      const mask = MaskParser.parse(maskString);
      if (!mask)
        return;
      await this.autoMoveFile(file, mask);
    } catch (error) {
      errorHandler.handleFileOperationError(
        error instanceof Error ? error : new Error(String(error)),
        { fileName: file.name, operation: "checkFrontmatterChanges" }
      );
    }
  }
  openMaskBuilder() {
    if (!this.settings.enabled) {
      new import_obsidian10.Notice("Mask Builder \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445");
      return;
    }
    const modal = new MaskBuilderModal(
      this.app,
      this.fileManager,
      async (mask, content) => {
        await this.createFileFromMask(mask, content);
      }
    );
    modal.open();
  }
  async createFileFromMask(mask, content) {
    try {
      const template = this.settings.defaultTemplate || void 0;
      const file = await this.fileManager.createFileFromMask(mask, content, template);
      if (file) {
        this.app.workspace.openLinkText(file.path, "", true);
        const analytics2 = getAnalytics();
        if (analytics2) {
          analytics2.trackMaskCreated(mask.entity, true);
          analytics2.trackFileOperation("createFile", file.name, true);
        }
      }
    } catch (error) {
      errorHandler.handleFileOperationError(
        error instanceof Error ? error : new Error(String(error)),
        { operation: "createFileFromMask", mask }
      );
      const analytics2 = getAnalytics();
      if (analytics2) {
        analytics2.trackMaskCreated(mask.entity, false);
        analytics2.trackFileOperation("createFile", "unknown", false);
      }
      new import_obsidian10.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043E\u043D\u0441\u043E\u043B\u044C.");
    }
  }
  async createNoteFromMask() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const mask = this.extractMaskFromFileName(activeFile.name);
    if (!mask) {
      new import_obsidian10.Notice("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0438\u0437\u0432\u043B\u0435\u0447\u044C \u043C\u0430\u0441\u043A\u0443 \u0438\u0437 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    await this.createFileFromMask(mask, content);
  }
  async validateCurrentFileMask() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const mask = this.extractMaskFromFileName(activeFile.name);
    if (!mask) {
      new import_obsidian10.Notice("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0438\u0437\u0432\u043B\u0435\u0447\u044C \u043C\u0430\u0441\u043A\u0443 \u0438\u0437 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const validation = MaskParser.validate(mask);
    if (validation.valid) {
      new import_obsidian10.Notice("\u041C\u0430\u0441\u043A\u0430 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430");
    } else {
      new import_obsidian10.Notice(`\u041E\u0448\u0438\u0431\u043A\u0438 \u0432 \u043C\u0430\u0441\u043A\u0435: ${validation.errors.join(", ")}`);
    }
  }
  async moveCurrentFileByMask() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const mask = this.extractMaskFromFileName(activeFile.name);
    if (!mask) {
      new import_obsidian10.Notice("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0438\u0437\u0432\u043B\u0435\u0447\u044C \u043C\u0430\u0441\u043A\u0443 \u0438\u0437 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const success = await this.fileManager.moveFileByMask(activeFile, mask);
    if (success) {
      this.app.workspace.openLinkText(activeFile.path, "", true);
    }
  }
  async loadSettings() {
    try {
      const raw = await this.loadData();
      const merged = { ...DEFAULT_SETTINGS, ...raw != null ? raw : {} };
      this.settings = migrateSettings(merged);
    } catch (error) {
      errorHandler.handleError(
        error instanceof Error ? error : new Error(String(error)),
        "unknown" /* UNKNOWN */,
        "high" /* HIGH */,
        { operation: "loadSettings" }
      );
      this.settings = DEFAULT_SETTINGS;
    }
  }
  async saveSettings() {
    try {
      await this.saveData(this.settings);
    } catch (error) {
      errorHandler.handleError(
        error instanceof Error ? error : new Error(String(error)),
        "unknown" /* UNKNOWN */,
        "high" /* HIGH */,
        { operation: "saveSettings" }
      );
    }
  }
  openDebugPanel() {
    const debugPanel = new DebugPanel(this.app);
    debugPanel.open();
  }
  openAnalyticsPanel() {
    const analyticsPanel = new AnalyticsPanel(this.app);
    analyticsPanel.open();
  }
  createRibbonMenu() {
    var _a;
    if (!this.settings.enabled || !((_a = this.settings.ribbonMenu) == null ? void 0 : _a.enabled)) {
      return;
    }
    this.ribbonContainer = document.createElement("div");
    this.ribbonContainer.addClass("mask-builder-ribbon-container");
    const mainContainer = this.app.workspace.containerEl;
    mainContainer.appendChild(this.ribbonContainer);
    if (!this.ribbonContainer.parentNode) {
      document.body.appendChild(this.ribbonContainer);
    }
    const options = {
      position: this.settings.ribbonMenu.position || "bottom",
      actions: this.settings.ribbonMenu.actions || [],
      onAction: (action, context) => {
        this.handleRibbonAction(action, context);
      }
    };
    this.ribbonMenu = new RibbonMenu(this.app, options);
    this.ribbonMenu.create(this.ribbonContainer);
    this.updateRibbonMenuPosition();
  }
  handleRibbonAction(action, context) {
    switch (action.action) {
      case "create":
        this.openMaskBuilder();
        break;
      case "format":
        this.formatCurrentNote();
        break;
      case "api":
        this.sendToAPI();
        break;
      case "custom":
        this.handleCustomAction(action);
        break;
      default:
        new import_obsidian10.Notice(`\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435 "${action.action}" \u043D\u0435 \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u043D\u043E`);
    }
  }
  handleCustomAction(action) {
    const customAction = action.customAction;
    if (!customAction) {
      return;
    }
    switch (customAction) {
      case "saveTemplate":
        this.saveAsTemplate();
        break;
      case "exportMarkdown":
        this.exportMarkdown();
        break;
      case "editFrontmatter":
        this.editFrontmatter();
        break;
      case "createFrontmatter":
        this.createFrontmatter();
        break;
      case "openNotes":
        this.openNotes();
        break;
      case "openProjects":
        this.openProjects();
        break;
      case "openDecisions":
        this.openDecisions();
        break;
      default:
        new import_obsidian10.Notice(`\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435 "${customAction}" \u043D\u0435 \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u043D\u043E`);
    }
  }
  forceCreateRibbonMenu() {
    if (this.ribbonContainer && this.ribbonContainer.parentNode) {
      this.ribbonContainer.parentNode.removeChild(this.ribbonContainer);
    }
    if (this.ribbonMenu) {
      this.ribbonMenu.destroy();
    }
    this.createRibbonMenu();
    new import_obsidian10.Notice("\u041B\u0435\u043D\u0442\u043E\u0447\u043D\u043E\u0435 \u043C\u0435\u043D\u044E \u043F\u0435\u0440\u0435\u0441\u043E\u0437\u0434\u0430\u043D\u043E!");
  }
  checkRibbonMenuStatus() {
  }
  updateRibbonMenuPosition() {
    if (!this.ribbonContainer)
      return;
    const leftPanel = this.app.workspace.leftSplit;
    const rightPanel = this.app.workspace.rightSplit;
  }
  //      
  formatCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      new import_obsidian10.Notice(`\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438: ${activeFile.name}`);
    } else {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F");
    }
  }
  sendToAPI() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      new import_obsidian10.Notice(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0432 API: ${activeFile.name}`);
    } else {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0438");
    }
  }
  saveAsTemplate() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      new import_obsidian10.Notice(`\u0421\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D: ${activeFile.name}`);
    } else {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F");
    }
  }
  exportMarkdown() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      new import_obsidian10.Notice(`\u042D\u043A\u0441\u043F\u043E\u0440\u0442 Markdown: ${activeFile.name}`);
    } else {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0430");
    }
  }
  editFrontmatter() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      new import_obsidian10.Notice(`\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440\u0430: ${activeFile.name}`);
    } else {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F");
    }
  }
  createFrontmatter() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      new import_obsidian10.Notice(`\u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440\u0430: ${activeFile.name}`);
    } else {
      new import_obsidian10.Notice("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0444\u0440\u043E\u043D\u0442\u043C\u0430\u0442\u0442\u0435\u0440\u0430");
    }
  }
  openNotes() {
    new import_obsidian10.Notice("\u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043E\u043A");
  }
  openProjects() {
    new import_obsidian10.Notice("\u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435 \u043F\u0440\u043E\u0435\u043A\u0442\u043E\u0432");
  }
  openDecisions() {
    new import_obsidian10.Notice("\u041E\u0442\u043A\u0440\u044B\u0442\u0438\u0435 \u0440\u0435\u0448\u0435\u043D\u0438\u0439");
  }
};
